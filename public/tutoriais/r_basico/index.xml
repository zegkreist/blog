<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Overview | Vugudum</title>
    <link>/tutoriais/r_basico/</link>
      <atom:link href="/tutoriais/r_basico/index.xml" rel="self" type="application/rss+xml" />
    <description>Overview</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pt-br</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Overview</title>
      <link>/tutoriais/r_basico/</link>
    </image>
    
    <item>
      <title>R basicão</title>
      <link>/tutoriais/r_basico/r_init/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      <guid>/tutoriais/r_basico/r_init/</guid>
      <description>

&lt;h1 id=&#34;r-básico&#34;&gt;R - Básico&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;r-em-container&#34;&gt;R em Container&lt;/h2&gt;

&lt;p&gt;Agora que já se sabe como subir imagens de docker, vamos subir uma de R studio server com vários pacotes instalados para poder praticar.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;CASO NÃO QUEIRA PASSAR POR ISSO/ JÁ TEM UMA VERSÃO DO R INSTALADA E APENAS QUER VER UNS COMANDINHOS PULE PARA PROCESSA ETAMA (OLHE O TABLE OF CONTENTS DO LADO DIREITO)&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Primeiro, vamos criar uma pasta de trabalho para o &lt;code&gt;docker-compose.yml&lt;/code&gt; que iremos utilizar (assumindo que estamos num Linux, caso não esteja faça como achar melhor no seu sistema).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir /home/${USER}/docker_compose_rstudio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos viajar lá para dentro.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /home/${USER}/docker_compose_rstudio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora vamos criar uma pasta persistente para montarmos dentro do container. (Caso queira saber mais sobre isso olhe o tutorialzinho de docker que eu fiz, também aqui no VUGUDUM)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir /home/${USER}/Projetos_R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Criar um arquivo &lt;code&gt;docker-compose.yml&lt;/code&gt; já com tudo dentro &lt;strong&gt;(Coloque uma senha melhor para sua pessoa).&lt;/strong&gt; Esta imagem &lt;code&gt;zegkreist/r-dl-cpu&lt;/code&gt; foi criada por mim, ela possui quase tudo que um cientista de dados precisa (por isso ela é gigante ~ 9GB, caso queira outra com RStudio se sinta tranquilo para fazer o que você &amp;ldquo;querÊ&amp;rdquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;
version: &#39;2&#39;
services:
  r-dl-cpu_teste:
    image: zegkreist/r-dl-cpu
    container_name: r_server_1
    restart: always
    environment:
     - USER=$USER
     - USERID=1000
     - PASSWORD=123facil
    ports:
     - &amp;quot;8787:8787&amp;quot;
    volumes:
     - /home/${USER}/Projetos_R:/home/teste/Projetos_R:rw &amp;quot; &amp;gt; /home/${USER}/docker_compose_rstudio/docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suba o serviço do rstudio server utilizando o &lt;code&gt;docker-compose&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acesse em &lt;a href=&#34;http://127.0.0.1:8787&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:8787&lt;/a&gt; se for na sua máquina local ou &lt;a href=&#34;http://ip_da_sua_instancia:8787&#34; target=&#34;_blank&#34;&gt;http://ip_da_sua_instancia:8787&lt;/a&gt;. O login será seu usuário (rode &lt;code&gt;echo $USER&lt;/code&gt; no console para descobrir) e a senha será a que você escolheu. Caso esteja numa instância remota que fique claro que a conexão aqui é apenas HTTP, para transforma-la em HTTPS precisa fazer um rolê aí que não irei explicar aqui, pois não é o foco.&lt;/p&gt;

&lt;p&gt;Sua pessoa chegará numa tela parecida com essa.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;rstudio_server_entrada.png&#34; alt=&#34;GUI do Rstudio&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Observe que há 4 áreas principais&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Source: onde está o editor de códigos e arquivos txt&lt;/li&gt;
&lt;li&gt;Environment/History/Conn/Git: Onde mostra os objetos declarados (há também outras abas, como history dos comandos rodados, connections, git, etc)&lt;/li&gt;
&lt;li&gt;Console: Onde os script são executados (há também outras abas, como terminal em que você pode executar comandos no console do seu OS, &lt;strong&gt;como estamos dentro de um serviço em container este terminal é sobre o OS do container, um Debian&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Files/Packages/Plot/Help: Aqui está uma espécie de &amp;lsquo;navegador&amp;rsquo;, você pode olhar os arquivos nas pastas vizinhas, olhar as figuras geradas pelo R, usar o Help para pesquisa de comandos, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Antes de começarmos a praticar vamos criar um projeto. Um projeto no R possui um work directory, seta o &amp;ldquo;home&amp;rdquo; do projeto como este work directory, salva o histórico de códigos rodados neste projeto, facilita commit utilizando o git, assim como o push para o repositório. Então, &lt;strong&gt;SEMPRE&lt;/strong&gt; faça as coisas dentro de um projeto, melhor organização  ..  melhor código.&lt;/p&gt;

&lt;p&gt;Vamos criar uma pasta para o projeto, navegue para dentro da pasta &lt;code&gt;Projetos_R&lt;/code&gt; clique em &lt;code&gt;New Folder&lt;/code&gt; e crie uma nova paste com o nome do projeto, pode ser &lt;code&gt;inicio&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;new_folder.png&#34; alt=&#34;Local para criar a nova pasta&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;nome_folder.png&#34; alt=&#34;Nome do folder&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora vamos criar um novo projeto nesta pasta, para isso vá no canto direito superior em:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;novo_projeto.png&#34; alt=&#34;E clique new project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clique em diretório já existente e selecione a pasta
&lt;img src=&#34;novo_projeto_2.png&#34; alt=&#34;Novo Projeto&#34; /&gt;&lt;/p&gt;

&lt;p&gt;E CRIE SEU PROJETOOO!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;novo_projeto_3.png&#34; alt=&#34;Projetinho&#34; /&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Pronto, estamos dentro de um projeto mais organizado e controlado, todo script que salvar será nessa sua pasta criada. Vamos iniciar um novo script, no canto esquerdo superior há um sinal de positivo em verde sobre uma folha branca, clique nele e vá em Rscript.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;novo_script.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora podemos começar a brincar com o R!!!!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;objetos&#34;&gt;Objetos&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;O R é uma linguagem funcional, tudo e qualquer coisa no R é uma chamada de função, porém algumas coisas podem ser vistas como objetos, são elas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vetor&lt;/li&gt;
&lt;li&gt;Matriz&lt;/li&gt;
&lt;li&gt;Data-frame&lt;/li&gt;
&lt;li&gt;Lista&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Há pacotes que possuem versões alternativas desses objetos como veremos mais a frente, mas veremos o que está no base por enquanto.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;vetores&#34;&gt;Vetores&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;O vetor é um array de uma dimensão, ou uma matriz &lt;code&gt;\(1 \times n\)&lt;/code&gt;. Há várias formas de declarar um vetor. Podemos declarar numeric, integer, character, date, int64, etc, veja algumas delas:&lt;/p&gt;

&lt;p&gt;Diretamente.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- c(1,2,3,4)
a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usando uma sequência que pula de um em um.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1:4
a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usando a função de sequência informando a quantidade que deve ser pulado.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- seq(1, 4, by = 1)
a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usando uma função que repete um determinado valor &lt;code&gt;\(n\)&lt;/code&gt; vezes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- rep(1, 10)
a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] 1 1 1 1 1 1 1 1 1 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;b &amp;lt;- rep(&amp;quot;eita&amp;quot;, 3)
b
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;eita&amp;quot; &amp;quot;eita&amp;quot; &amp;quot;eita&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A primeira posição do vetor é &lt;code&gt;1&lt;/code&gt; e usamos a função &lt;code&gt;[&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1:10

#primeira posicao
a[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#ultima posicao
a[length(a)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#as primeiras 4 posicoes
a[1:4]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;b &amp;lt;- LETTERS
b[1:10]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;A&amp;quot; &amp;quot;B&amp;quot; &amp;quot;C&amp;quot; &amp;quot;D&amp;quot; &amp;quot;E&amp;quot; &amp;quot;F&amp;quot; &amp;quot;G&amp;quot; &amp;quot;H&amp;quot; &amp;quot;I&amp;quot; &amp;quot;J&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#output de length(a)
length(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 10
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;matrizes&#34;&gt;Matrizes&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Assim como no C++ uma matriz pode ser vista como um vetor de vetores de mesmo tamanho. No R a matriz deve ser apenas de um tipo, ou seja, todas as colunas devem ser do mesmo tipo, como numeric, character, etc. Para declarar uma matriz primeiro e necessário declarar um vetor e reposicioná-lo com a função matrix. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor_inicial &amp;lt;- 1:9

matriz &amp;lt;- matrix(data = vetor_inicial,
                 ncol = 3,
                 byrow = T
                 )

matriz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;: Informo o vetor que será reposicionado&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ncol&lt;/code&gt;: informo quantas colunas a matriz terá&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byrow&lt;/code&gt;: informo como será a distribuição&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Se fizermos com &lt;code&gt;byrow = F&lt;/code&gt; temos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;matriz &amp;lt;- matrix(data = vetor_inicial,
                 ncol = 3,
                 byrow = F
                 )

matriz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para sabermos a dimensão da matriz basta utilizar &lt;code&gt;dim(matriz)&lt;/code&gt;.
O modo de acesso é semelhante ao vetor, utilizando a função &lt;code&gt;[&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#primeira posicao
matriz[1,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#segunda posicao
matriz[1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#primeira linha
matriz[1,]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 4 7
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#primeira coluna
matriz[,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos ainda nomear as colunas ou linhas e chamá-las pelo nome, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;colnames(matriz) &amp;lt;- c(&amp;quot;primeira&amp;quot;, &amp;quot;segunda&amp;quot;, &amp;quot;terceira&amp;quot;)

matriz[,&amp;quot;primeira&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#ou ainda um conjunto de colunas

matriz[, c(&amp;quot;primeira&amp;quot;, &amp;quot;segunda&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      primeira segunda
## [1,]        1       4
## [2,]        2       5
## [3,]        3       6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que, eu declarei um vetor de nomes &lt;code&gt;c(&amp;quot;primeira&amp;quot;, &amp;quot;segunda&amp;quot;)&lt;/code&gt; dentro do local de definição das colunas, eu poderia ter feito anteriormente, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;subset_c &amp;lt;- c(&amp;quot;primeira&amp;quot;, &amp;quot;segunda&amp;quot;)
matriz[, subset_c]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      primeira segunda
## [1,]        1       4
## [2,]        2       5
## [3,]        3       6
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;data-frame&#34;&gt;Data-frame&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;O data-frame é um &amp;lsquo;objeto&amp;rsquo; semelhante à uma matriz, porém necessita de ter as colunas nomeadas. Cada coluna é um vetor independente do outro, podendo assim ser de tipos diferentes. Há também formas diferentes de acesso ao data-frame.&lt;/p&gt;

&lt;p&gt;Vamos declarar um data-frame para podermos explorá-lo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.frame(id      = 1:10, #integer
                    letras  = LETTERS[1:10], #character factor
                    numeros = runif(n = 10, min = 1, max = 100) #numeric
                    )
head(dados)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##   id letras  numeros
## 1  1      A 98.08171
## 2  2      B 43.00829
## 3  3      C 26.86298
## 4  4      D 40.94583
## 5  5      E 16.11603
## 6  6      F 48.42628
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos acessar o data-frame de forma semelhante à matriz, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[1,] # Primeira linha
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##   id letras  numeros
## 1  1      A 98.08171
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[,1] # Primeira coluna
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, &amp;quot;letras&amp;quot;] #coluna letras
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] A B C D E F G H I J
## Levels: A B C D E F G H I J
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#podemos acessar ainda utilizando o operador $, veja:

dados$letras # Desta forma acessamos o vetor diretamente
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] A B C D E F G H I J
## Levels: A B C D E F G H I J
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;listas&#34;&gt;Listas&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;As listas são contêineres que podem guardar qualquer tipo de objeto do R em seus slots, seria quase uma espécie de JSON (ou &lt;code&gt;map&lt;/code&gt; em outras linguagens). Veja a seguinte declaração:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista &amp;lt;- list(
  primeira_pos = 1:3,
  segunda_pos  = data.frame(col_1 = 1:10),
  terceira_pos = list(
    inception = &amp;quot;YEAH&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos acessar seus conteúdos. Basicamente utilizaremos a função &lt;code&gt;[[&lt;/code&gt; e o operador (que também é uma função) &lt;code&gt;$&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista[&amp;quot;primeira_pos&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## $primeira_pos
## [1] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# os seguintes abaixo sao equivalentes
lista[[1]] # vetor de fato
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$primeira_pos # vetor de fato
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, navegando pelo data.frame da segunda posição.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#acessando primeira coluna do data.frame armazenado na lista
lista[[2]]$col_1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista[[&amp;quot;segunda_pos&amp;quot;]]# data.frame
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    col_1
## 1      1
## 2      2
## 3      3
## 4      4
## 5      5
## 6      6
## 7      7
## 8      8
## 9      9
## 10    10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$segunda_pos # data.frame
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    col_1
## 1      1
## 2      2
## 3      3
## 4      4
## 5      5
## 6      6
## 7      7
## 8      8
## 9      9
## 10    10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$segunda_pos$col_1 # primeira coluna do data.frame
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$segunda_pos$col_1 # primeira coluna do data.frame
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora acessando a lista dentro da lista.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$terceira_pos # lista segundo nivel
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## $inception
## [1] &amp;quot;YEAH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista[[&amp;quot;terceira_pos&amp;quot;]][[&amp;quot;inception&amp;quot;]] # resultado da lista segundo nivel
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;YEAH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista[[&amp;quot;terceira_pos&amp;quot;]]$inception # resultado da lista segundo nivel
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;YEAH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lista$terceira_pos$inception # resultado da lista segundo nivel
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;YEAH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;tipos&#34;&gt;Tipos&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;No R temos basicamente &lt;code&gt;numeric&lt;/code&gt; (seria um float), &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;character&lt;/code&gt;, &lt;code&gt;factor&lt;/code&gt; (um tipo especial de &lt;code&gt;character&lt;/code&gt;), &lt;code&gt;posix&lt;/code&gt;/ &lt;code&gt;date&lt;/code&gt; (um tipo especial de &lt;code&gt;character&lt;/code&gt;), &lt;code&gt;logical&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;. Existem alguns pacotes do R que expandem os tipos, adicionando coisas como &lt;code&gt;int64&lt;/code&gt; por exemplo. Com a função &lt;code&gt;class&lt;/code&gt; é possível observar o tipo de variáveis, vejamos alguns exemplos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(lubridate) # pacote que adiciona tipo date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Loading required package: lubridate
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;lubridate&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:base&#39;:
## 
##     date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- .1
b &amp;lt;- 1L
c &amp;lt;- &#39;eita&#39;
d &amp;lt;- &amp;quot;Eita&amp;quot;
e &amp;lt;- factor(c(&#39;a&#39;,&#39;b&#39;,&amp;quot;c&amp;quot;,&amp;quot;D&amp;quot;))
f &amp;lt;- Sys.time()
g &amp;lt;- 1+1i
h &amp;lt;- c(T,F, TRUE, FALSE)
i &amp;lt;- c(1,2,&amp;quot;a&amp;quot;,T) # CUIDADO PARA NÃO MISTURAR OS TIPOS
j &amp;lt;- c(1,2,T,F)   # CUIDADO PARA NÃO MISTURAR OS TIPOS
l &amp;lt;- lubridate::as_date(Sys.time())


 cat(paste0(c(&amp;quot;Tipo: a &amp;quot;, class(a), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: b &amp;quot;, class(b), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: c &amp;quot;, class(c), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: d &amp;quot;, class(d), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: e &amp;quot;, class(e), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: f &amp;quot;, class(f), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: g &amp;quot;, class(g), &amp;quot;\n&amp;quot;, 
              &amp;quot;Tipo: h &amp;quot;, class(h), &amp;quot;\n&amp;quot;,
              &amp;quot;Tipo: i &amp;quot;, class(i), &amp;quot;\n&amp;quot;,
              &amp;quot;Tipo: j &amp;quot;, class(j), &amp;quot;\n&amp;quot;,
              &amp;quot;Tipo: l &amp;quot;, class(l), &amp;quot;\n&amp;quot;
              ),
            collapse = &amp;quot; &amp;quot;
            )
     )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Tipo: a  numeric 
##  Tipo: b  integer 
##  Tipo: c  character 
##  Tipo: d  character 
##  Tipo: e  factor 
##  Tipo: f  POSIXct POSIXt 
##  Tipo: g  complex 
##  Tipo: h  logical 
##  Tipo: i  character 
##  Tipo: j  numeric 
##  Tipo: l  Date
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;No R podemos fazer as operações básicas &lt;code&gt;+-*/^&lt;/code&gt;, mas também há outras como &lt;code&gt;%*%&lt;/code&gt;, &lt;code&gt;%%&lt;/code&gt; e &lt;code&gt;%in%&lt;/code&gt; e até mesmo filtros (que aqui estou chamando de operações).&lt;/p&gt;

&lt;p&gt;Os seguintes &lt;code&gt;+-*/^&lt;/code&gt; tem caráter de operação escalar, veja os exemplos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- c(1,2,3,4)
b &amp;lt;- c(2,2,2,2)

1+1 # escalar 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;10*5 # escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 50
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;2^4 #escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 16
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a*2 # escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 2 4 6 8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a/2 # escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 0.5 1.0 1.5 2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a^2 # escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1]  1  4  9 16
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a*b #escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 2 4 6 8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a+b #escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a^2 # escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1]  1  4  9 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O operador &lt;code&gt;%%&lt;/code&gt; é o resto de uma divisão, e &lt;code&gt;%/%&lt;/code&gt; a parte inteira de uma divisão, então:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;4%%3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;4%%2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;7%/%2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;10%/%2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O operador &lt;code&gt;%*%&lt;/code&gt; é a multiplicação de matrizes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- matrix(c(1:9), ncol = 3, byrow = T)
B &amp;lt;- matrix(c(1:9), ncol = 3, byrow = F)

A%*%B # Multiplicacao de matriz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]   14   32   50
## [2,]   32   77  122
## [3,]   50  122  194
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A+B # soma escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    2    6   10
## [2,]    6   10   14
## [3,]   10   14   18
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A*B # multiplicacao escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    8   21
## [2,]    8   25   48
## [3,]   21   48   81
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A^2 # potencia escalar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    4    9
## [2,]   16   25   36
## [3,]   49   64   81
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A%*%A #potencia matricial
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]   30   36   42
## [2,]   66   81   96
## [3,]  102  126  150
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;hail-to-all-mighty-pipe&#34;&gt;HAIL to all mighty PIPE&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;O R possui um operador peculiar provindo de um pacote chamado &lt;code&gt;magrittr&lt;/code&gt;. Ele oferece uma facilidade viciante, por isso ficou tão popular que é comum quando um novo pacote está sendo feito para o R os autores implementam as features necessárias para que o pipe também seja utilizado em conjunto com suas funções. Como dito anteriormente, tudo no R é uma função, e estas funções podem ser redefinidas, podemos inclusive trocar os significados dos operados &lt;code&gt;+-*/&lt;/code&gt;, mas isto seria besteira.&lt;/p&gt;

&lt;p&gt;O pipe é um operador que faz o seguinte: &lt;code&gt;lhs %&amp;gt;%  lhs&lt;/code&gt;, seu comportamento é passar o &lt;code&gt;lhs&lt;/code&gt; para ser avaliado em &lt;code&gt;lhs&lt;/code&gt;. Então, seja &lt;code&gt;x&lt;/code&gt; algum objeto e &lt;code&gt;foo&lt;/code&gt; uma função, assim &lt;code&gt;x %&amp;gt;% f&lt;/code&gt; é equivalente a &lt;code&gt;f(x)&lt;/code&gt;. Caso &lt;code&gt;f&lt;/code&gt; necessite múltiplos argumentos, o comportamento padrão é que o objeto &lt;code&gt;x&lt;/code&gt; seja colocado na primeira posição de &lt;code&gt;f&lt;/code&gt;, ou seja, &lt;code&gt;x %&amp;gt;% f(y)&lt;/code&gt; é equivalente a &lt;code&gt;f(x,y)&lt;/code&gt;. Podemos escolher a posição que será inserido da seguinte forma &lt;code&gt;x %&amp;gt;% f(y, .)&lt;/code&gt; é equivalente a &lt;code&gt;f(y,x)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mas por que o pipe é tão utilizado? Imagine que tenhamos um objeto &lt;code&gt;x&lt;/code&gt;e necessitamos de fazer várias operações encadeadas, o pipe permite que o código fique mais organizado. EXEMPLO:&lt;/p&gt;

&lt;p&gt;Vamos criar um vetor &lt;code&gt;x&lt;/code&gt;, calcular seu comprimento e calcular a média de uma amostra aleatória de mesmo tamanho. É um exemplo bobo, mas já ilustra o potencial da criança.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1:100

#modo 1
n &amp;lt;- length(x)
result &amp;lt;- sample(1000, size = n)
result &amp;lt;- mean(result)

#modo 2
result &amp;lt;- sample(1000, size = length(x))
result &amp;lt;- mean(result)

#modo 3
result &amp;lt;- mean(sample(1000, size = length(x)))
# THE KING

result &amp;lt;- x %&amp;gt;% 
  length() %&amp;gt;% 
  sample(1000, size = .) %&amp;gt;% 
  mean()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observe que utilizando o pipe, o código basicamente vira um bullet de uma apresentação de slide, a leitura é direta. Vou colocar um exemplo de código aqui embaixo, veja que não explicarei nada do código, esta apostila é para iniciante na linguagem (então suponho que não está familiarizado com o R) e mesmo assim terá uma capacidade alta de compreensão do que está sendo feito.&lt;/p&gt;

&lt;p&gt;Seja &lt;code&gt;dados&lt;/code&gt; um conjunto de dados qualquer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;result &amp;lt;- dados %&amp;gt;% 
  dplyr::filter(ano &amp;gt;= &amp;quot;2018-01-01&amp;quot;) %&amp;gt;% 
  dplyr::group_by(CodProcedimento) %&amp;gt;% 
  dplyr::summarise(media = mean(ValorUtilizacao))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apenas leia, é literalmente uma receita de bolo.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pegue dados&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Filtre para ano &amp;gt;= &amp;ldquo;2018-01-01&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Agrupe por CodProcedimento&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calcule a média do Valor Utilização&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamos reescrever isso de um jeito &lt;strong&gt;nojento&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;result &amp;lt;- dplyr::summarise(dplyr::group_by(dplyr::filter(dados,
                                                         ano &amp;gt;= &amp;quot;2018-01-01&amp;quot;),
                                           CodProcedimento),
                           media = mean(ValorUtilizacao)
                           )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É bem fácil de entender até a parte do &lt;code&gt;dplyr::summarise&lt;/code&gt;, depois disso&amp;hellip;&lt;/p&gt;

&lt;p&gt;Porém não iremos utilizar o pacote &lt;code&gt;dplyr&lt;/code&gt; para fazer manipulações, é bonitinho porém não performa bem.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;filtros-e-subsets&#34;&gt;Filtros e subsets&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;No R devemos evitar o máximo possível fazer laços (&lt;code&gt;for&lt;/code&gt; ou &lt;code&gt;while&lt;/code&gt;). Temos outras ferramentas para busca e para aplicar funções repetidamente, como as funções da família &lt;code&gt;apply&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo mostrarei como fazer subsets e filtros.&lt;/p&gt;

&lt;p&gt;Image que tenhamos um vetor que gostaríamos de selecionar todos os número maior que um threshold. Podemos utilizar vetores lógicos para fazer essa seleção. Primeiro, vamos demonstrar a criação de um vetor lógico.&lt;/p&gt;

&lt;p&gt;Suponha o seguinte vetor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- runif(20,1,10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos criar um vetor lógico indicador, vamos supor que gostaríamos de marcar todo número menor que 5.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor_logico &amp;lt;- a &amp;lt; 5
vetor_logico
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE
## [12]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora podemos selecionar posições em &lt;code&gt;a&lt;/code&gt; informando quem &amp;lsquo;desligar&amp;rsquo; e a quem retornar, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a[vetor_logico]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133
## [9] 2.706487
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# podemos escrever diretamente
a[a &amp;lt; 5] # quero a, onde a é menor que 5
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133
## [9] 2.706487
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora queremos as posições de &lt;code&gt;a&lt;/code&gt; que são menores que 5&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;which(a &amp;lt; 5 )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1]  5 10 11 12 13 14 16 17 20
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pos &amp;lt;- which(a &amp;lt; 5)

a[pos]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133
## [9] 2.706487
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos também negar um vetor lógico (basicamente pegando o contrário)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a[!vetor_logico]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] 6.385984 8.736175 7.104037 8.203882 6.494243 6.770594 9.450312
##  [8] 6.899342 7.313048 7.928868 7.744817
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os vetores lógicos possuem algumas propriedades, por exemplo &lt;code&gt;TRUE = 1&lt;/code&gt; e &lt;code&gt;FALSE = 0&lt;/code&gt;, então podemos fazer operações com isso. Queremos saber quantos números em &lt;code&gt;a&lt;/code&gt; são menores que 5, então podemos fazer assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum(a &amp;lt; 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 9
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ou assim
length(a[a &amp;lt; 5])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos zerar os números menores que 5:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a*!vetor_logico
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] 6.385984 8.736175 7.104037 8.203882 0.000000 6.494243 6.770594
##  [8] 9.450312 6.899342 0.000000 0.000000 0.000000 0.000000 0.000000
## [15] 7.313048 0.000000 0.000000 7.928868 7.744817 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ou podemos trocar no proprio objeto

a[a &amp;lt; 5] &amp;lt;- 0 
a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] 6.385984 8.736175 7.104037 8.203882 0.000000 6.494243 6.770594
##  [8] 9.450312 6.899342 0.000000 0.000000 0.000000 0.000000 0.000000
## [15] 7.313048 0.000000 0.000000 7.928868 7.744817 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos utilizar outros vetores de mesmo tamanho para fazer esse filtro, caso as informações sejam casadas. Vamos supor um &lt;code&gt;data.frame&lt;/code&gt; e trabalhar com ele para esses filtros&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.frame(id      = 1:20, #integer
                    letras  = LETTERS[1:20], #character factor
                    numeros = runif(n = 20, min = 1, max = 100) #numeric
                    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Queremos as letras da coluna &lt;code&gt;letras&lt;/code&gt; que possuam um número da coluna &lt;code&gt;numeros&lt;/code&gt; menor que 50.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados$letras[dados$numeros &amp;lt; 50]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] B D E F G H K N O P R S T
## Levels: A B C D E F G H I J K L M N O P Q R S T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos definir um outro &lt;code&gt;data.frame&lt;/code&gt; com esse filtro&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados1 &amp;lt;- dados[dados$numeros &amp;lt; 50, ]
head(dados1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##   id letras   numeros
## 2  2      B  1.518690
## 4  4      D  3.384159
## 5  5      E 23.287412
## 6  6      F 28.360873
## 7  7      G  9.157979
## 8  8      H 41.689610
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nós usamos muito os vetores lógicos, em todos os lugares. Porém não vou me prolongar aqui, farei isso quando estivermos falando de &lt;code&gt;data.table&lt;/code&gt; que é redesenho do &lt;code&gt;data.frame&lt;/code&gt;. É utilizando ele que faremos todas as manipulações alá banco de dados, por que ele? por isso:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Máquina do benchmark.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intel&amp;reg; Xeon&amp;reg; CPU E5-2660 v3 @ 2.60GHz&lt;/p&gt;

&lt;p&gt;20 CPU CORE&lt;/p&gt;

&lt;p&gt;125.8 GB RAM&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src=&#34;DT_POWER.png&#34; alt=&#34;DT POWER&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;laços&#34;&gt;Laços&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Como disse antes, é bom que evitemos laços ao máximo, mas há momentos que não tem tal possibilidade. Utilizando as funções da família &lt;code&gt;apply&lt;/code&gt; podemos substitui praticamente qualquer laço sem o overhead gigantesco (se comparado a outras linguagens) que ele causa. Porém o código fica confuso, é mais complicado pensar na arquitetura da operação, etc. Então há lugares que de fato é proveitoso usar um laço, normalmente quando os planetas se alinham da seguinte forma:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;O passeio é curto: quando é necessário poucas iterações ( menor que 1000).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A carga é pesada: quando o que se calcula no seu interior é pesado a tal ponto que o overhead gerado pelo loop em si seja irrelevante.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por que o número 1000 em poucas iterações? Normalmente quando se precisa de mais iterações do que isso significa que o processo interno é leve, feito em batchs, há outras formas ( e muito melhores) para se lidar com isso do que um loop. Sua pessoa deve usar e abusar da vetorização que o R oferece. Sempre que criar uma função, pense em aplicá-la para o vetor ou matriz inteira e não de forma escalar.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;for&#34;&gt;For&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;O exemplo que usarei aqui é simples, lembre-se que contas leves não deve ser feito num loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;result &amp;lt;- numeric(20) # sempre que possível pre aloque o vetor de resultados
for(i in 1:20){
  result[i] &amp;lt;- i^2
}
result
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]   1   4   9  16  25  36  49  64  81 100 121 144 169 196 225 256 289
## [18] 324 361 400
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos testar uns tempos?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rbenchmark::benchmark(
  &amp;quot;sem_alocar&amp;quot; = {
    result &amp;lt;- c()
    for(i in 1:2000){
      result[i] &amp;lt;- i^2
      }
    },
  &amp;quot;pre_alocado&amp;quot; = {
    result &amp;lt;- numeric(2000) # sempre que possível pre aloque o vetor de resultados
    for(i in 1:2000){
      result[i] &amp;lt;- i^2
      }
    },
  &amp;quot;vetorizado&amp;quot; ={
    (1:2000)^2
    },
  order = &amp;quot;relative&amp;quot;,
  replications = 100,
  columns = c(&amp;quot;test&amp;quot;, &amp;quot;replications&amp;quot;, &amp;quot;relative&amp;quot;, &amp;quot;elapsed&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##          test replications relative elapsed
## 3  vetorizado          100        1   0.001
## 2 pre_alocado          100      240   0.240
## 1  sem_alocar          100      273   0.273
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observe a velocidade relativa, o método &lt;strong&gt;vetorizado&lt;/strong&gt; é a base, observe que o método &lt;strong&gt;sem_alocar&lt;/strong&gt; é o mais demorado, quantas vezes mais lento? Muito não?!? Agora observe que caso o tamanho do &lt;code&gt;result&lt;/code&gt; seja pré alocado é um pouco mais rápido, mas nem de longe comparado com a versão vetorizada.&lt;/p&gt;

&lt;p&gt;Temos também as condições que podem ser inseridas num &lt;code&gt;for&lt;/code&gt; para quando satisfeita alguma condição específica:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;break&lt;/code&gt;: Para o loop, saindo dele&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;next&lt;/code&gt;: Pula essa iteração indo para a próxima&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;while&#34;&gt;While&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Particularmente acho que da para contar nos dedos de uma mão as vezes em que utilizei o &lt;code&gt;while&lt;/code&gt;, acredito que apenas em simulações, esperando algo convergir, etc. Segue o exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;result &amp;lt;- numeric(20)
i &amp;lt;- 1
while(i &amp;lt;= 20){
  result[i] &amp;lt;- i
  i &amp;lt;- i+1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As condições &lt;code&gt;next&lt;/code&gt;e &lt;code&gt;break&lt;/code&gt; também funcionam para o &lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;if-or-else&#34;&gt;IF &amp;hellip; or ELSE!!&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;A lógica para esses caras é como para qualquer outra linguagem, tem apenas um porém em relação à uma função em específico &lt;code&gt;ifelse&lt;/code&gt; que pode facilitar algumas coisas.&lt;/p&gt;

&lt;p&gt;A estrutura se inicia por um &lt;code&gt;if&lt;/code&gt; com uma determinada condição e logo depois um &lt;code&gt;else&lt;/code&gt; opcional. Lembrando que esta condição deve ter comprimento 1, não podendo ser um vetor lógico.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1
if(a == 1){
  &amp;quot;EITA PORRA&amp;quot;
}else{
  &amp;quot;Eita nada&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;EITA PORRA&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 0
if(a == 1){
  &amp;quot;EITA PORRA&amp;quot;
}else{
  &amp;quot;Eita nada&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Eita nada&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 0
if(a != 1){
  &amp;quot;EITA PORRA&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;EITA PORRA&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 0
if(a &amp;gt; 1){
  &amp;quot;EITA PORRA&amp;quot;
} # nao retorna nada
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;ifelse&lt;/code&gt; permite ser aplicada num vetor lógico.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- c(T,T,F,T,F,F)

result &amp;lt;- ifelse(test = a,
                 yes  = &amp;quot;EITAAAA&amp;quot;,
                 no   = &amp;quot;EITA NAAOO&amp;quot;
                 )

result
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;EITAAAA&amp;quot;    &amp;quot;EITAAAA&amp;quot;    &amp;quot;EITA NAAOO&amp;quot; &amp;quot;EITAAAA&amp;quot;    &amp;quot;EITA NAAOO&amp;quot;
## [6] &amp;quot;EITA NAAOO&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Onde o &lt;code&gt;test&lt;/code&gt; é uma condição ou um vetor de condições, como embaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- runif(10,1,10)

result &amp;lt;- ifelse(test = a &amp;lt; 5,
                 yes  = &amp;quot;EITAAAA&amp;quot;,
                 no   = &amp;quot;EITA NAAOO&amp;quot;
                 )
dados &amp;lt;- data.frame(A         = a,
                    condicoes = a &amp;lt; 5,
                    saida     = result
                    )
dados
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##           A condicoes      saida
## 1  7.588302     FALSE EITA NAAOO
## 2  5.560936     FALSE EITA NAAOO
## 3  4.385240      TRUE    EITAAAA
## 4  2.665477      TRUE    EITAAAA
## 5  2.307467      TRUE    EITAAAA
## 6  2.449290      TRUE    EITAAAA
## 7  2.920070      TRUE    EITAAAA
## 8  8.914990     FALSE EITA NAAOO
## 9  3.729306      TRUE    EITAAAA
## 10 4.224658      TRUE    EITAAAA
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;funções&#34;&gt;Funções&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;No R tudo são funções, então também temos que fazer nossas próprias funções. Para declarar uma função podemos deixar sem argumentos ou quantos quisermos. Eles podem ter valores default ou não. O ultimo valor a ser retornado que a função irá retornar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo &amp;lt;- function(){
  &amp;quot;eita&amp;quot;
}

foo1 &amp;lt;- function(){
  &amp;quot;eita&amp;quot;
  &amp;quot;eita_porra&amp;quot;
}

foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;eita&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo1()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;eita_porra&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ou ainda podemos deixar explicitado o que será retornado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo2 &amp;lt;- function(){
  &amp;quot;eita&amp;quot;
  &amp;quot;eita_porra&amp;quot;
  return(&amp;quot;isso aqui sera retornado&amp;quot;)
}

foo2()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;isso aqui sera retornado&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos colocar um argumento e com alguma &amp;ldquo;mastigação&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo3 &amp;lt;- function(argumento){
  result &amp;lt;- paste0(&amp;quot;Mastigando: &amp;quot;, argumento)
  return(result)
}

foo3(argumento = &amp;quot;E I T A !1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mastigando: E I T A !1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas se tentarmos rodar sem especificar um argumento um erro é retornado. Tente rodar o seguinte comando no seu console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos definir um valor default para este argumento:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo4 &amp;lt;- function(argumento = &amp;quot;Valor Default&amp;quot;){
    result &amp;lt;- paste0(&amp;quot;Mastigando: &amp;quot;, argumento)
    return(result)
}

foo4()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mastigando: Valor Default&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NÃO RECOMENDO, mas podemos utilizar uma função para alterar um valor no enviroment global do R. Semelhante a usar uma função que retorna &lt;code&gt;void&lt;/code&gt; no c++ e usar ponteiros para alterar informações &amp;ldquo;in place&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1:10
foo5 &amp;lt;- function(){
  a[a &amp;lt; 5] &amp;lt;&amp;lt;- 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja o vetor &lt;code&gt;a&lt;/code&gt; como ele é:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos rodar a função que modifica inplace por referência.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;foo5()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora vejamos &lt;code&gt;a&lt;/code&gt; novamente.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] 100 100 100 100   5   6   7   8   9  10
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;loading-75&#34;&gt;Loading |======&amp;mdash;| 75%&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Dados, vamos aprender a carregar dados. O R tem vários pacotes que nos permitem carregar praticamente qualquer tipo de dado, JSON, csv, txt, Rdata, RDS, até aqueles vindo de programas como excel, stata, access, SPSS, etc. Basta procurar, porém inicialmente nos preocupemos apenas com arquivos csv/txt e dados provindo de bancos.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;csv-e-txt&#34;&gt;CSV e TXT&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Temos uma função milagrosa que consegue fazer o parse do arquivo texto e carregar em velocidades astronômicas, esta função também é proveniente do nosso querido e amado &lt;code&gt;data.table&lt;/code&gt;. Ele também fornece uma função estupidamente rápida para escrever esses dados em csv ou txt.&lt;/p&gt;

&lt;p&gt;Vamos primeiro criar um arquivo txt para podermos treinar os carregamentos, isto implica que primeiro iremos aprender a escrever para depois ler. Já vamos iniciando no &lt;code&gt;data.table&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(data.table) # No R devemos carregar as bibliotecas que iremos utilizar previamente
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;data.table&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:lubridate&#39;:
## 
##     hour, isoweek, mday, minute, month, quarter, second, wday,
##     week, yday, year
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#####
# Observe que, além de ter carregado a blibioteca,
# eu tambem indiquei na funcao abaixo de qual biblioteca ela provem (utilizando data.table:: antes da funcao)
# este e um passo opcional, mas acredito que para um codigo em producao isso deve ser feito
#####

dados &amp;lt;- data.table::data.table(id      = 1:50000,
                                numeros = runif(50000, 1, 100),
                                letras  = sample(LETTERS, 50000, replace = T)
                                )

## vamos escrever
data.table::fwrite(dados, &amp;quot;dados_example.txt&amp;quot;)
## Vamos rodar um comando  no bash do linux para compactar o arquivo
system(&amp;quot;gzip &amp;lt; dados_example.txt &amp;gt; dados_example.txt.gz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;fwrite&lt;/code&gt; se diz respeito à escrita de um arquivo texto no filesystem. Estou utilizando as configurações default, em que basicamente seleciona-se separador de campos como vírgula, strings que possuem o separador contido nelas estão entre aspas, e a primeira linha se trata do nome das colunas.&lt;/p&gt;

&lt;p&gt;Explicando a compressão. A função &lt;code&gt;system&lt;/code&gt; executa a string no console bash do linux. O que lemos nessa string? Eu aponto o arquivo .txt para o programa gzip da seguinte forma &lt;code&gt;gzip &amp;lt; dados_example.txt&lt;/code&gt; e pego o resultado disso e coloco para o arquivo &lt;code&gt;dados_example.txt.gz&lt;/code&gt; usando o apontamento &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Vamos verificar os tamanhos dos arquivos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;file.size(&amp;quot;dados_example.txt.gz&amp;quot;)/1000000 #mb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 0.586925
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;file.size(&amp;quot;dados_example.txt&amp;quot;)/1000000 #mb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 1.233302
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos carregar o arquivo original utilizando a função &lt;code&gt;fread&lt;/code&gt; do &lt;code&gt;data.table&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.table::fread(&amp;quot;dados_example.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Carregando pelo arquivo comprimido&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.table::fread(&amp;quot;zcat dados_example.txt.gz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;fread&lt;/code&gt; faz o parse automático do arquivo. Porém é possível adicionar argumentos a mais como qual string é responsável pela separação &lt;code&gt;sep&lt;/code&gt;, qual o padrão de decimal utilizado no arquivo &lt;code&gt;dec&lt;/code&gt;, e inúmeros outros. Para ver todos os argumentos procure pelo nome da função na aba de &lt;code&gt;help&lt;/code&gt; do canto direito da IDE do Rstudio.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;leitura-do-banco-de-dados&#34;&gt;Leitura do banco de dados&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Para se ler do banco de dados é necessário primeiramente criar uma conexão com o banco. Esta conexão pode ser feita de várias formas diferentes e cada banco de dados possui uma forma diferente. Para o SQL SERVER utilizaremos o driver ODBC oficial da Microsoft (que já se encontra nessa imagem de docker). Porém não temos um banco de testes aqui, farei um exemplo se conectando ao MySQL de um dos nosso servidores (mas mostrando um código dummy).&lt;/p&gt;

&lt;p&gt;É necessário a criação de um objeto de conexão com o banco. Este objeto pode ser criado por inúmeros pacotes diferentes, aqui irei utilizar uma combinação do pacote &lt;code&gt;DBI&lt;/code&gt; e &lt;code&gt;RMariaDB&lt;/code&gt;. O MariaDB é um fork do próprio MySQL, dos mesmos criadores, que ocorreu quando este foi comprado. O conector do &lt;code&gt;RMariaDB&lt;/code&gt; é eficiente e funciona bem com o MySQL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Carregando pacotes necessarios
library(DBI)
library(RMariaDB)

## Criando objeto de conexao
con &amp;lt;- DBI::dbConnect(RMariaDB::MariaDB(),
                      user=&#39;SUPER USUARIO&#39;, 
                      password=&#39;SENHA FODA BAGARAI&#39;,
                      #dbname= database.,
                      dbname=&#39;DW_name_cliente&#39;,
                      host=&#39;192.168.134.63&#39;,
                      encoding = &amp;quot;latin1&amp;quot;,
                      bigint = &amp;quot;character&amp;quot;
                      )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora que temos o objeto de conexão &lt;code&gt;con&lt;/code&gt;, iremos utilizá-lo como operador para passar requisições para o banco. Vamos mudar uma configuração do banco, aumentar o limite de tempo para que ele corte o nossa conexão inexplicável.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;DBI::dbExecute(con, 
               paste0(&amp;quot;SET GLOBAL connect_timeout = 600000;&amp;quot;)
               )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que fazemos? Utilizamos a função &lt;code&gt;dbExecute&lt;/code&gt; e passamos o objeto de conexão com o qual ela irá lidar. Após isso passamos uma string que será executada, apesar de eu ter me utilizado da função &lt;code&gt;paste0&lt;/code&gt;, poderíamos ter passado a string diretamente. A função &lt;code&gt;paste0&lt;/code&gt; nos permite compor strings utilizando valores de outros objetos.&lt;/p&gt;

&lt;p&gt;Vamos agora executar uma query para puxar os dados para um objeto do R.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;query &amp;lt;- &amp;quot;SELECT  *
          FROM  T_FatoUtilizacao WHERE DtUtilizacao &amp;gt;= &#39;2018-01-01&#39; AND DtUtilizacao &amp;lt;= &#39;2018-12-31&#39;;&amp;quot;

dados &amp;lt;- DBI::dbGetQuery(con, query) %&amp;gt;% 
  data.table::setDT()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primeiro, crio um objeto com a consulta que será aplicada, depois utilizo da função &lt;code&gt;dbGetQuery&lt;/code&gt; que executará a query armazenada no objeto &lt;code&gt;query&lt;/code&gt; na conexão &lt;code&gt;con&lt;/code&gt;. Após isso, redireciono a saída delas função com o operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; para a função &lt;code&gt;setDT&lt;/code&gt; que irá transformar este objeto, in-place, num objeto data.table.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>R Data Table</title>
      <link>/tutoriais/r_basico/r_datatable/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      <guid>/tutoriais/r_basico/r_datatable/</guid>
      <description>

&lt;h1 id=&#34;r-data-table&#34;&gt;R - Data.Table&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;O data.table nada mais é do que uma reimaginação do data.frame do R. Ele é escrito primariamente em C. Possui uma série de otimizações focando em velocidade e economia de memória. Temos a liberdade de fazer operações inplace, evitando cópias desnecessárias que agridem a memória e demandam tempo.&lt;/p&gt;

&lt;p&gt;Seja &lt;code&gt;dados&lt;/code&gt; um objeto data.table. Nosso acesso as manipulações ocorrem pela função &lt;code&gt;[]&lt;/code&gt;, temos a seguinte estrutura:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;data.table.png&#34; alt=&#34;Slots&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Temos 3 slots:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro, &lt;code&gt;i&lt;/code&gt;: É a região dos filtros&lt;/li&gt;
&lt;li&gt;Segundo,&lt;code&gt;j&lt;/code&gt;: É a região do que iremos fazer. Criar colunas? Dropar colunas? Agregação?&lt;/li&gt;
&lt;li&gt;Terceiro, &lt;code&gt;by&lt;/code&gt;: É a região dos grupos, mas algumas vezes pode servir como filtro também, como num caso de JOIN.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seria algo com &lt;code&gt;dados[where, select|update|do, by]&lt;/code&gt;. Vamos começar com a parte do &lt;code&gt;where&lt;/code&gt;, para isso vamos introduzir a função &lt;code&gt;setkey&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;filtro&#34;&gt;Filtro&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Já que iremos filtrar, vamos filtrar de forma eficiente.
A função &lt;code&gt;setkey&lt;/code&gt; tem como objetivo estabelecer um índice. A serventia é a mesma que num banco de dados, isto é feito para que, numa busca seja feito busca binária e não vector scan. &lt;strong&gt;Um ponto de atenção é que o objeto data.table é ordenado de acordo com o índice&lt;/strong&gt;, dependendo do que está sendo feito isto pode ser um problema.&lt;/p&gt;

&lt;p&gt;Vamos criar um dado sintético para trabalhar de tamanho razoável.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.table(categoria = sample.int(4, 10000000, replace = T),
                    valor     = rnorm(10000000, mean = 1000, sd = 20),
                    sexo      = sample.int(2, 10000000, replace = T)
                    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temos um conjunto de dados de 10 milhões de linhas. Criamos dados fake, categoria, valor e sexo. Vamos criar um objeto que receba apenas os dados da categoria 1 e 2. Mas primeiro criaremos um índice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setkey(dados,categoria)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos comparar o filtro utilizando a chave e sem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rbenchmark::benchmark(
  &amp;quot;sem_key&amp;quot; = {
    filtro1 &amp;lt;- dados[categoria == 1 | categoria == 2]
    },
  &amp;quot;com_key&amp;quot; ={
    filtro2 &amp;lt;- dados[.(c(1,2))]
    },
  order = &amp;quot;relative&amp;quot;,
  replications = 1,
  columns = c(&amp;quot;test&amp;quot;, &amp;quot;replications&amp;quot;, &amp;quot;relative&amp;quot;, &amp;quot;elapsed&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      test replications relative elapsed
## 2 com_key            1    1.000   0.101
## 1 sem_key            1    1.842   0.186
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;São iguais?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all(filtro1 == filtro2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A versão sem chave é mais lenta. Mas repare a velocidade com que filtramos uma tabela de 10 milhões de linhas e copiamos para um objeto novo em ambas as versões.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Agora vamos explicar melhor.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Quando não temos uma chave criada, filtramos o conjunto de dados utilizando vetores lógicos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[categoria == 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##          categoria     valor sexo
##       1:         1  983.1805    2
##       2:         1 1020.7571    2
##       3:         1 1041.2756    1
##       4:         1  984.5988    2
##       5:         1  981.9217    2
##      ---                         
## 2501239:         1 1018.7187    2
## 2501240:         1 1028.5804    1
## 2501241:         1 1045.4142    1
## 2501242:         1  993.8039    2
## 2501243:         1  998.1015    2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perceba que, eu faço referência ao nome da coluna de forma direta internamente. Podemos compor este vetor lógico de outras formas, utilizando outras colunas também, veja.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[categoria == 1 &amp;amp; valor &amp;gt;= 1000 &amp;amp; sexo == 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##         categoria    valor sexo
##      1:         1 1041.276    1
##      2:         1 1012.897    1
##      3:         1 1010.089    1
##      4:         1 1018.702    1
##      5:         1 1020.278    1
##     ---                        
## 624581:         1 1025.785    1
## 624582:         1 1016.047    1
## 624583:         1 1020.169    1
## 624584:         1 1028.580    1
## 624585:         1 1045.414    1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Porém, quando assim fazemos, não nos utilizamos da busca binária. Para usá-la precisamos criar as chaves e usar uma lista para passar os argumentos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setkey(dados, categoria, sexo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não irei fazer busca num range de valor na busca binária, mas chegarei no mesmo resultado. Iremos fazer o mesmo filtro.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[.(1,1)][valor &amp;gt;= 1000]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##         categoria    valor sexo
##      1:         1 1041.276    1
##      2:         1 1012.897    1
##      3:         1 1010.089    1
##      4:         1 1018.702    1
##      5:         1 1020.278    1
##     ---                        
## 624581:         1 1025.785    1
## 624582:         1 1016.047    1
## 624583:         1 1020.169    1
## 624584:         1 1028.580    1
## 624585:         1 1045.414    1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vejamos a diferença:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rbenchmark::benchmark(
  &amp;quot;sem_key&amp;quot; = {
    filtro1 &amp;lt;- dados[categoria == 1 &amp;amp; valor &amp;gt;= 1000 &amp;amp; sexo == 1]
    },
  &amp;quot;com_key&amp;quot; ={
    filtro2 &amp;lt;- dados[.(1,1)][valor &amp;gt;= 1000]
    },
  order = &amp;quot;relative&amp;quot;,
  replications = 1,
  columns = c(&amp;quot;test&amp;quot;, &amp;quot;replications&amp;quot;, &amp;quot;relative&amp;quot;, &amp;quot;elapsed&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##      test replications relative elapsed
## 2 com_key            1     1.00   0.028
## 1 sem_key            1     5.75   0.161
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;São iguais?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all(filtro1 == filtro2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observe que não estamos contando o tempo necessário para se criar as chaves. Porém quase sempre é melhor fazer a chave, pois podemos pensar numa chave que favoreça o maior número possível de filtros que será feito.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;agregações-mutate&#34;&gt;Agregações / Mutate&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Agora vamos trabalhar na segunda parte do &lt;code&gt;data.table&lt;/code&gt;, no &amp;ldquo;o que iremos fazer&amp;rdquo;. Aqui vamos fazer agregações. Temos 3 colunas, duas que indicam categorias e uma que indica um valor. Então, faremos alguns cálculos utilizando a coluna valor. Vamos crar um novo objeto &lt;code&gt;data.table&lt;/code&gt; que tenha a média e desvio padrão deste valor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados1 &amp;lt;- dados[, .(media_valor         = mean(valor),
                    desvio_padrao_valor = sd(valor)
                    )
                ]
dados1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    media_valor desvio_padrao_valor
## 1:    1000.004            20.00367
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que vemos nesta expressão?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dados[,&lt;/code&gt;: Não queremos fazer nenhum filtro, então deixamos seu respectivo espaço em branco.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.(&lt;/code&gt;: Está função &lt;code&gt;.&lt;/code&gt; é um alias para a função &lt;code&gt;list&lt;/code&gt;. Estamos passando uma lista com as expressões que são feitas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;media_valor = mean(valor)&lt;/code&gt;: Aqui nomeio a nova coluna à esquerda da igualdade. No lado direito escrevo a expressão, aqui faço a média da coluna &lt;code&gt;valor&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamos fazer o mesmo procedimento, só que para valores maiores que 1000.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados1 &amp;lt;- dados[valor &amp;gt; 1000, .(media_valor         = mean(valor),
                    desvio_padrao_valor = sd(valor)
                    )
                ]
dados1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    media_valor desvio_padrao_valor
## 1:    1015.969            12.05818
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao contrário da expressão anterior, adicionamos um filtro no espaço destinado a ele. Podemos reescrever isso de outra forma, já mostrada anteriormente, fazendo primeiro um &lt;code&gt;data.table&lt;/code&gt; filtrado e continuando os cálculos. Isto pode ser feito com o pipe ou usando a função &lt;code&gt;[&lt;/code&gt;, a segunda é mais recomendada pois não gera cópias.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# com pipe
library(magrittr)
dados1A &amp;lt;- dados[valor &amp;gt; 1000] %&amp;gt;% 
  .[, .(media_valor         = mean(valor),
        desvio_padrao_valor = sd(valor)
        )
    ]

#Com os []

dados1B &amp;lt;- dados[valor &amp;gt; 1000
                 ][
                   , .(media_valor         = mean(valor),
                       desvio_padrao_valor = sd(valor)
                       )
                 ]

all(dados1A == dados1B)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perceba que, criamos um novo objeto com o resultado. Porém, muitas vezes, se faz necessário adicionar essa informação como uma nova coluna, mesmo que ela seja redundante. Para isso, utilizaremos um outra função para escrever as expressões, a função &lt;code&gt;:=&lt;/code&gt;. Veja.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, media_valor := mean(valor)]
dados[, desvio_padrao_valor := sd(valor)]
dados
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##           categoria     valor sexo media_valor desvio_padrao_valor
##        1:         1 1041.2756    1    1000.004            20.00367
##        2:         1  989.1302    1    1000.004            20.00367
##        3:         1  978.7430    1    1000.004            20.00367
##        4:         1  998.9086    1    1000.004            20.00367
##        5:         1 1012.8971    1    1000.004            20.00367
##       ---                                                         
##  9999996:         4 1018.1498    2    1000.004            20.00367
##  9999997:         4  981.9318    2    1000.004            20.00367
##  9999998:         4 1000.6837    2    1000.004            20.00367
##  9999999:         4  987.9402    2    1000.004            20.00367
## 10000000:         4 1038.9378    2    1000.004            20.00367
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;:=&lt;/code&gt; também é utilizada para deleter colunas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, c(&amp;quot;media_valor&amp;quot;, &amp;quot;desvio_padrao_valor&amp;quot;) := NULL]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para utilizarmos uma mesma chamada para criar várias colunas novas, devemos utilizar a seguinte forma.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, `:=`(media_valor         = mean(valor),
             desvio_padrao_valor = sd(valor)
             )
      ]
head(dados)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria     valor sexo media_valor desvio_padrao_valor
## 1:         1 1041.2756    1    1000.004            20.00367
## 2:         1  989.1302    1    1000.004            20.00367
## 3:         1  978.7430    1    1000.004            20.00367
## 4:         1  998.9086    1    1000.004            20.00367
## 5:         1 1012.8971    1    1000.004            20.00367
## 6:         1 1010.0885    1    1000.004            20.00367
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;:=&lt;/code&gt; altera o &lt;code&gt;data.table&lt;/code&gt; inplace, então tome cuidado quando for alterar colunas já existentes. A exemplo, vamos alterar uma coluna já existente utilizando de filtros.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[valor &amp;gt; 1000,
      `:=`(media_valor         = mean(valor),
           desvio_padrao_valor = sd(valor)
           )
      ]
head(dados)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria     valor sexo media_valor desvio_padrao_valor
## 1:         1 1041.2756    1    1015.969            12.05818
## 2:         1  989.1302    1    1000.004            20.00367
## 3:         1  978.7430    1    1000.004            20.00367
## 4:         1  998.9086    1    1000.004            20.00367
## 5:         1 1012.8971    1    1015.969            12.05818
## 6:         1 1010.0885    1    1015.969            12.05818
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observou que alguns dos dados da coluna alterada aparentam serem os mesmos? A coluna só foi alterada onde a condição do filtro é satisfeita, que é &lt;code&gt;valor &amp;gt; 1000&lt;/code&gt;. Veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setorder(dados, valor)
dados[c(1:5, (nrow(dados)-5):nrow(dados))]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     categoria     valor sexo media_valor desvio_padrao_valor
##  1:         2  900.4804    2    1000.004            20.00367
##  2:         3  902.8411    1    1000.004            20.00367
##  3:         1  903.1211    1    1000.004            20.00367
##  4:         2  903.4796    1    1000.004            20.00367
##  5:         4  903.6676    1    1000.004            20.00367
##  6:         4 1100.1116    1    1015.969            12.05818
##  7:         4 1100.5020    1    1015.969            12.05818
##  8:         2 1101.6412    1    1015.969            12.05818
##  9:         4 1102.5581    1    1015.969            12.05818
## 10:         3 1103.1713    2    1015.969            12.05818
## 11:         3 1105.0339    1    1015.969            12.05818
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos criar agora uma label para a variável &lt;code&gt;sexo&lt;/code&gt;. Veremos o que acontecerá.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setkey(dados, sexo)
dados[.(sexo = 1), SexoBeneficiario := &amp;quot;Masculino&amp;quot;]
dados[c(1,500,10000000)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria     valor sexo media_valor desvio_padrao_valor
## 1:         3  902.8411    1    1000.004            20.00367
## 2:         3  926.0478    1    1000.004            20.00367
## 3:         3 1103.1713    2    1015.969            12.05818
##    SexoBeneficiario
## 1:        Masculino
## 2:        Masculino
## 3:             &amp;lt;NA&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu solicitei a impressão das linhas 1, 500 e 10000000. Veja a variável que criamos, observe que para onde as condições do filtro não foram satisfeitas não foi aplicado nenhum valor para a nova variável &lt;code&gt;SexoBeneficiario&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[.(sexo = 2), SexoBeneficiario := &amp;quot;Feminino&amp;quot;]
dados[c(1,500,10000000)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria     valor sexo SexoBeneficiario
## 1:         3  902.8411    1        Masculino
## 2:         3  926.0478    1        Masculino
## 3:         3 1103.1713    2         Feminino
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pronto, podemos fazer isso de outra forma, veremos qual será mais rápido, para isso iremos deletar esta coluna.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, SexoBeneficiario := NULL]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;options(datatable.verbose=F, datatable.auto.index = F)
rbenchmark::benchmark(
  &amp;quot;sem_key_ifelse&amp;quot; = {
    dados[, SexoBeneficiario1 := ifelse(sexo == 1, &amp;quot;Masculino&amp;quot;, &amp;quot;Feminino&amp;quot;)]
    },
  &amp;quot;sem_key_data.table&amp;quot;= {
    dados[sexo == 1, SexoBeneficiario2 := &amp;quot;Masculino&amp;quot;]
    dados[sexo == 2, SexoBeneficiario2 := &amp;quot;Feminino&amp;quot;]
  },
  &amp;quot;com_key&amp;quot; ={
    dados[.(sexo = 1), SexoBeneficiario3 := &amp;quot;Masculino&amp;quot;]
    dados[.(sexo = 2), SexoBeneficiario3 := &amp;quot;Feminino&amp;quot;]

    },
  order = &amp;quot;relative&amp;quot;,
  replications = 1,
  columns = c(&amp;quot;test&amp;quot;, &amp;quot;replications&amp;quot;, &amp;quot;relative&amp;quot;, &amp;quot;elapsed&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##                 test replications relative elapsed
## 2 sem_key_data.table            1    1.000   0.209
## 3            com_key            1    1.033   0.216
## 1     sem_key_ifelse            1    8.321   1.739
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;São iguais?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all(dados$SexoBeneficiario2 == dados$SexoBeneficiario3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora vamos ativar a função de auto index do &lt;code&gt;data.table&lt;/code&gt;. O que ela faz? Basicamente observar quais filtros irá fazer e cria um índice por trás dos panos. Porém ele não reordena o objeto em si, é criado uma coluna com esse índice nos atributos do objeto. Ainda é mais lento do que criar uma Chave, mas já ajuda bastante, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;options(datatable.verbose=F, datatable.auto.index = T)

rbenchmark::benchmark(
  &amp;quot;sem_key_ifelse&amp;quot; = {
    dados[, SexoBeneficiario1 := ifelse(sexo == 1L, &amp;quot;Masculino&amp;quot;, &amp;quot;Feminino&amp;quot;)]
    },
  &amp;quot;sem_key_data.table&amp;quot;= {
    dados[sexo == 1L, SexoBeneficiario2 := &amp;quot;Masculino&amp;quot;]
    dados[sexo == 2L, SexoBeneficiario2 := &amp;quot;Feminino&amp;quot;]
  },
  &amp;quot;com_key&amp;quot; ={
    dados[.(sexo = 1L), SexoBeneficiario3 := &amp;quot;Masculino&amp;quot;]
    dados[.(sexo = 2L), SexoBeneficiario3 := &amp;quot;Feminino&amp;quot;]

    },
  order = &amp;quot;relative&amp;quot;,
  replications = 1,
  columns = c(&amp;quot;test&amp;quot;, &amp;quot;replications&amp;quot;, &amp;quot;relative&amp;quot;, &amp;quot;elapsed&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##                 test replications relative elapsed
## 3            com_key            1    1.000   0.165
## 2 sem_key_data.table            1    1.073   0.177
## 1     sem_key_ifelse            1    9.945   1.641
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O index apenas funciona para &lt;code&gt;==&lt;/code&gt; e &lt;code&gt;%in%&lt;/code&gt;. Uma coisa que devemos ter cuidado é sempre utilizar os tipos certos para se fazer comparação e para atribuir valores, conversões saem caras em questão de performance, assim sempre que possível devemos atribuir as coisas de forma correta, como em &lt;code&gt;sexo == 1L&lt;/code&gt; aqui eu especifico com o &lt;code&gt;L&lt;/code&gt; que o número à esquerda é um inteiro.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;agrupamento&#34;&gt;Agrupamento&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Nós já fizemos agregações na sessão anterior. Iremos fazer a exata mesma coisa, porém agora podemos agrupar os cálculos em grupos (basicamente o &lt;code&gt;GROUP BY&lt;/code&gt; de qualquer SQL).&lt;/p&gt;

&lt;p&gt;Vamos utilizar o mesmo mesmo exemplo anterior, só que agora agrupando por &lt;code&gt;categoria&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Limpe seus dados (caso ainda o tenha) e libere a memória.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rm(dados)
gc(reset = T)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##           used (Mb) gc trigger  (Mb) max used (Mb)
## Ncells  599594 32.1    1069260  57.2   599594 32.1
## Vcells 3693424 28.2   90661241 691.7  3693424 28.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos declarar o dados novamente&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados &amp;lt;- data.table(categoria = sample.int(4, 10000000, replace = T),
                    valor     = rnorm(10000000, mean = 1000, sd = 20),
                    sexo      = sample.int(2, 10000000, replace = T)
                    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iremos calcular a média e desvio padrão para cada nível da variável &lt;code&gt;categoria&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, .(media_valor         = mean(valor),
          desvio_padrao_valor = sd(valor)
          ),
      by = .(categoria)
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria media_valor desvio_padrao_valor
## 1:         4    999.9855            19.99456
## 2:         2    999.9867            20.00855
## 3:         1   1000.0115            20.00871
## 4:         3    999.9952            19.99853
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta foi uma agregação, um resumo, vamos criar as mesmas duas métricas para cada categoria, um mutate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, `:=`(media_valor = mean(valor),
             desvio_padrao_valor = sd(valor)
             ),
      by = .(categoria)
      ]

head(dados)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria     valor sexo media_valor desvio_padrao_valor
## 1:         4 1006.5045    2    999.9855            19.99456
## 2:         4  999.9418    2    999.9855            19.99456
## 3:         2  984.4775    2    999.9867            20.00855
## 4:         1 1030.6272    2   1000.0115            20.00871
## 5:         1  995.2280    1   1000.0115            20.00871
## 6:         2 1000.1660    1    999.9867            20.00855
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Também podemos fazer agrupamentos por mais de uma variável. Aqui será feito com &lt;code&gt;categoria&lt;/code&gt; e &lt;code&gt;sexo&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dados[, .(media_valor         = mean(valor),
          desvio_padrao_valor = sd(valor)
          ),
      by = .(categoria, sexo)
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    categoria sexo media_valor desvio_padrao_valor
## 1:         4    2    999.9882            19.98116
## 2:         2    2    999.9859            20.01013
## 3:         1    2   1000.0132            20.00674
## 4:         1    1   1000.0099            20.01069
## 5:         2    1    999.9875            20.00697
## 6:         4    1    999.9828            20.00795
## 7:         3    1    999.9711            19.98177
## 8:         3    2   1000.0192            20.01526
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;joinss&#34;&gt;JOINss&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;O &lt;code&gt;data.table&lt;/code&gt;tem seu modo de realizar JOINS e JOINS inplace. É eficiente, mas pode confundir um pouco.&lt;/p&gt;

&lt;p&gt;Primeiro iremos criar as tabelas, &lt;code&gt;A&lt;/code&gt; será um índice, contendo 1 e 2. &lt;code&gt;B&lt;/code&gt; será uma índice com uma label.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- data.table(id_A = sample.int(2, size = 10000,replace = T))
A[id_A == 1, label_A := &amp;quot;A&amp;quot;]
A[id_A == 2, label_A := &amp;quot;B&amp;quot;]

B &amp;lt;- data.table(id_B    = 1:2,
                label_B = c(&amp;quot;Masculino&amp;quot;, &amp;quot;Feminino&amp;quot;)
                )

head(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    id_A label_A
## 1:    2       B
## 2:    1       A
## 3:    2       B
## 4:    1       A
## 5:    2       B
## 6:    1       A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;B
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    id_B   label_B
## 1:    1 Masculino
## 2:    2  Feminino
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os JOINS podem ser definidos pela seguinte forma&lt;/p&gt;

&lt;h3 id=&#34;left-join&#34;&gt;LEFT JOIN&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### LEFT JOIN EM A com B
B[A, on =c(&amp;quot;id_B&amp;quot; = &amp;quot;id_A&amp;quot;)] # LEFT JOIN COM COPIA
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##        id_B   label_B label_A
##     1:    2  Feminino       B
##     2:    1 Masculino       A
##     3:    2  Feminino       B
##     4:    1 Masculino       A
##     5:    2  Feminino       B
##    ---                       
##  9996:    1 Masculino       A
##  9997:    1 Masculino       A
##  9998:    1 Masculino       A
##  9999:    1 Masculino       A
## 10000:    2  Feminino       B
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### LEFT JOIN EM A com B
A[B, label_B := label_B, on =c(&amp;quot;id_A&amp;quot; = &amp;quot;id_B&amp;quot;)] # LEFT JOIN SEM COPIA
A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##        id_A label_A   label_B
##     1:    2       B  Feminino
##     2:    1       A Masculino
##     3:    2       B  Feminino
##     4:    1       A Masculino
##     5:    2       B  Feminino
##    ---                       
##  9996:    1       A Masculino
##  9997:    1       A Masculino
##  9998:    1       A Masculino
##  9999:    1       A Masculino
## 10000:    2       B  Feminino
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### LEFT JOIN EM B com A
B[A, label_A := label_A, on =c(&amp;quot;id_B&amp;quot; = &amp;quot;id_A&amp;quot;)] # LEFT JOIN SEM COPIA
B
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    id_B   label_B label_A
## 1:    1 Masculino       A
## 2:    2  Feminino       B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para colocar várias colunas da tabela à direita para a direita num &lt;strong&gt;LEFT JOIN SEM COPIA&lt;/strong&gt; é necessário um pouco mais de trabalho. Veja, é só um pouco mais de trabalho.&lt;/p&gt;

&lt;p&gt;Primeiro, crio esta função auxiliar, ela irá construir o código responsável pelo &lt;code&gt;lhs := rhs&lt;/code&gt; de várias colunas e retorno como uma expressão do R. Após isso eu avalio essa expressão dentro do &lt;code&gt;data.table&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pull_right &amp;lt;- function(columns,exceptions){
  columns &amp;lt;- columns[!columns %in% exceptions]
  string &amp;lt;- paste( &amp;quot;`:=`(&amp;quot;,paste(columns, columns, sep = &amp;quot;=&amp;quot;, collapse = &amp;quot;,&amp;quot;), &amp;quot;)&amp;quot;)
 
  return(parse(text =string))
  }

pull_right(columns = c(&amp;quot;label_A&amp;quot;, &amp;quot;label_B&amp;quot;), exceptions = c(&amp;quot;id&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## expression(`:=`(label_A = label_A, label_B = label_B))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vejamos o exemplo anterior, utilizando desta função:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# DECLARANDO AS MATRIZES NOVAMENTE
A &amp;lt;- data.table(id_A = sample.int(2, size = 10000,replace = T))
A[id_A == 1, label_A := &amp;quot;A&amp;quot;]
A[id_A == 2, label_A := &amp;quot;B&amp;quot;]

B &amp;lt;- data.table(id_B    = 1:2,
                label_B = c(&amp;quot;Masculino&amp;quot;, &amp;quot;Feminino&amp;quot;)
                )
#
#
#
# LEFT JOIN IN PLACE
A[B,
  eval(pull_right(columns = &amp;quot;label_B&amp;quot;,
                  exceptions = &amp;quot;id_B&amp;quot;)
       ),
  on = .(id_A == id_B)
  ]
A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##        id_A label_A   label_B
##     1:    2       B  Feminino
##     2:    1       A Masculino
##     3:    2       B  Feminino
##     4:    2       B  Feminino
##     5:    1       A Masculino
##    ---                       
##  9996:    1       A Masculino
##  9997:    1       A Masculino
##  9998:    2       B  Feminino
##  9999:    1       A Masculino
## 10000:    2       B  Feminino
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;right-join&#34;&gt;RIGHT JOIN&lt;/h3&gt;

&lt;p&gt;Reimagine um RIGHT JOIN como um LEFT JOIN e faz como no passo anterior&lt;/p&gt;

&lt;h3 id=&#34;inner-join&#34;&gt;INNER JOIN&lt;/h3&gt;

&lt;p&gt;Vamos criar datasets de exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- data.table(id_A = 1:10,
                label_A = &amp;quot;alguma coisa&amp;quot;
                )
B &amp;lt;- data.table(id_B = 1:4,
                label_B = &amp;quot;MATCH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para o INNER JOIN FAZEMOS&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A[B, on = c(&amp;quot;id_A&amp;quot; = &amp;quot;id_B&amp;quot;), nomatch = 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    id_A      label_A label_B
## 1:    1 alguma coisa   MATCH
## 2:    2 alguma coisa   MATCH
## 3:    3 alguma coisa   MATCH
## 4:    4 alguma coisa   MATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;not-join&#34;&gt;NOT JOIN&lt;/h3&gt;

&lt;p&gt;Vamos criar datasets de exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- data.table(id_A = 1:10,
                label_A = &amp;quot;alguma coisa&amp;quot;
                )
B &amp;lt;- data.table(id_B = 1:4,
                label_B = &amp;quot;MATCH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para o NOT JOIN temos&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A[!B, on = c(&amp;quot;id_A&amp;quot; = &amp;quot;id_B&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    id_A      label_A
## 1:    5 alguma coisa
## 2:    6 alguma coisa
## 3:    7 alguma coisa
## 4:    8 alguma coisa
## 5:    9 alguma coisa
## 6:   10 alguma coisa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;non-equi-join&#34;&gt;NON EQUI JOIN&lt;/h3&gt;

&lt;p&gt;Este JOIN serve para quando queremos fazer um match baseado em desigualdade. Vamos a criação do dataset e ao exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- data.table(id_A = 1:20,
                label_A = &amp;quot;alguma coisa&amp;quot;
                )
B &amp;lt;- data.table(id_B = 15:25,
                label_B = &amp;quot;MATCH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vejamos A e B&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     id_A      label_A
##  1:    1 alguma coisa
##  2:    2 alguma coisa
##  3:    3 alguma coisa
##  4:    4 alguma coisa
##  5:    5 alguma coisa
##  6:    6 alguma coisa
##  7:    7 alguma coisa
##  8:    8 alguma coisa
##  9:    9 alguma coisa
## 10:   10 alguma coisa
## 11:   11 alguma coisa
## 12:   12 alguma coisa
## 13:   13 alguma coisa
## 14:   14 alguma coisa
## 15:   15 alguma coisa
## 16:   16 alguma coisa
## 17:   17 alguma coisa
## 18:   18 alguma coisa
## 19:   19 alguma coisa
## 20:   20 alguma coisa
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;B
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     id_B label_B
##  1:   15   MATCH
##  2:   16   MATCH
##  3:   17   MATCH
##  4:   18   MATCH
##  5:   19   MATCH
##  6:   20   MATCH
##  7:   21   MATCH
##  8:   22   MATCH
##  9:   23   MATCH
## 10:   24   MATCH
## 11:   25   MATCH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos fazer o match onde id_B é menor que id_A&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;B[A, on = .(id_B &amp;lt; id_A)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##     id_B label_B      label_A
##  1:    1    &amp;lt;NA&amp;gt; alguma coisa
##  2:    2    &amp;lt;NA&amp;gt; alguma coisa
##  3:    3    &amp;lt;NA&amp;gt; alguma coisa
##  4:    4    &amp;lt;NA&amp;gt; alguma coisa
##  5:    5    &amp;lt;NA&amp;gt; alguma coisa
##  6:    6    &amp;lt;NA&amp;gt; alguma coisa
##  7:    7    &amp;lt;NA&amp;gt; alguma coisa
##  8:    8    &amp;lt;NA&amp;gt; alguma coisa
##  9:    9    &amp;lt;NA&amp;gt; alguma coisa
## 10:   10    &amp;lt;NA&amp;gt; alguma coisa
## 11:   11    &amp;lt;NA&amp;gt; alguma coisa
## 12:   12    &amp;lt;NA&amp;gt; alguma coisa
## 13:   13    &amp;lt;NA&amp;gt; alguma coisa
## 14:   14    &amp;lt;NA&amp;gt; alguma coisa
## 15:   15    &amp;lt;NA&amp;gt; alguma coisa
## 16:   16   MATCH alguma coisa
## 17:   17   MATCH alguma coisa
## 18:   17   MATCH alguma coisa
## 19:   18   MATCH alguma coisa
## 20:   18   MATCH alguma coisa
## 21:   18   MATCH alguma coisa
## 22:   19   MATCH alguma coisa
## 23:   19   MATCH alguma coisa
## 24:   19   MATCH alguma coisa
## 25:   19   MATCH alguma coisa
## 26:   20   MATCH alguma coisa
## 27:   20   MATCH alguma coisa
## 28:   20   MATCH alguma coisa
## 29:   20   MATCH alguma coisa
## 30:   20   MATCH alguma coisa
##     id_B label_B      label_A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse é um JOIN bem confuso e é muito fácil fazer coisa errada. São raros os casos em que ele é necessário. Normalmente preenchimento de alguma coisa relacionada a uma linha temporal. Eu sugiro que tente usar ao máximo outras formas de fazer o que queira antes de tentar o NON EQUI JOINS.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
