<!DOCTYPE html>
<html lang="pt-br">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.4.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Navarro Rosa">

  
  
  
    
  
  <meta name="description" content="Comandos: run O comando run, quando não utilizado com outra ferramente de orquestração, como docker-compose, kubernets, ou outro, será o comando mais utilizado. Ele roda um container por meio de uma imagem, normalmente o container executa um comando e morre. A imagem hello-world basicamente executa um print de texto no console e depois morre (na verdade finaliza com sucesso). Se subirmos um script batch, será executado tudo que deve ser feito e depois o container morre.">

  
  <link rel="alternate" hreflang="pt-br" href="/tutoriais/docker/docker_commandos/">

  


  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.dd629241ea9333c62c071f4a25f829ff.css">

  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-148080553-1', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/tutoriais/docker/docker_commandos/">

  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@zegkreist">
  <meta property="twitter:creator" content="@zegkreist">
  
  <meta property="og:site_name" content="Vugudum">
  <meta property="og:url" content="/tutoriais/docker/docker_commandos/">
  <meta property="og:title" content="Docker Commands | Vugudum">
  <meta property="og:description" content="Comandos: run O comando run, quando não utilizado com outra ferramente de orquestração, como docker-compose, kubernets, ou outro, será o comando mais utilizado. Ele roda um container por meio de uma imagem, normalmente o container executa um comando e morre. A imagem hello-world basicamente executa um print de texto no console e depois morre (na verdade finaliza com sucesso). Se subirmos um script batch, será executado tudo que deve ser feito e depois o container morre."><meta property="og:image" content="/img/icon-192.png">
  <meta property="twitter:image" content="/img/icon-192.png"><meta property="og:locale" content="pt-br">
  
    
      <meta property="article:published_time" content="2019-08-01T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2019-08-01T00:00:00&#43;00:00">
  

  


  





  <title>Docker Commands | Vugudum</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Vugudum</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/tutoriais/"><span>Tutoriais</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>contato</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  

<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      





<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutoriais/docker/">Overview</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/tutoriais/docker/docker_installation/">Tutorial Docker</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/tutoriais/docker/docker_installation/">Docker Installation</a>
      </li>
      
      <li class="active">
        <a href="/tutoriais/docker/docker_commandos/">Docker Commands</a>
      </li>
      
      <li >
        <a href="/tutoriais/docker/docker_compose/">Docker Compose</a>
      </li>
      
    </ul>
    

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">Contents</a></li>
      </ul>

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#comandos-run">Comandos: run</a></li>
<li><a href="#comandos-container">Comandos: container</a></li>
<li><a href="#comandos-image">Comandos: image</a></li>
<li><a href="#comandos-prune">Comandos: prune</a></li>
<li><a href="#comandos-build">Comandos: build</a></li>
</ul></li>
</ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name">Docker Commands</h1>

          <div class="article-style" itemprop="articleBody">
            

<hr />

<h2 id="comandos-run">Comandos: run</h2>

<hr />

<p>O comando run, quando não utilizado com outra ferramente de orquestração, como docker-compose, kubernets, ou outro, será o comando mais utilizado. Ele roda um container por meio de uma imagem, normalmente o container executa um comando e morre. A imagem hello-world basicamente executa um print de texto no console e depois morre (na verdade finaliza com sucesso). Se subirmos um script batch, será executado tudo que deve ser feito e depois o container morre. Se subirmos um serviço contínuo o comportamento ainda é o mesmo, porém a &ldquo;sensação&rdquo; é outra, por exemplo, subimos um serviço de banco de dados, o comando que a imagem terá é executar o banco, a imagem continuará ativa durante toda a &ldquo;execução do comando&rdquo;, ou seja, a imagem só irá morrer caso o banco de dados morra por algum motivo.</p>

<p>Primeiro, há duas formas de executar uma imagem, no Foreground (seu console vai ficar preso no que for executado) e no Background (ou detached) o container será executada no plano de fundo.</p>

<p>Vamos subir um bash de uma imagem que seja um OS ubuntu em foreground:</p>

<pre><code class="language-sh">sudo docker run -it ubuntu bash
</code></pre>

<ul>
<li><code>run</code>: Comando que executa uma imagem</li>
<li><code>-it</code>: Argumentos para o comando run, <code>i</code> significa interativo, <code>t</code> ativa um tipo de buffer para entradas de texto</li>
<li><code>ubuntu</code>: O nome da imagem que será executado</li>
<li><code>bash</code>: O programa q será executado dentro da imagem, neste caso iniciaremos o console.</li>
</ul>

<p>Note que, agora você está num ambiente ubuntu, dentro do container Aqui você pode fazer qualquer coisa, inclusive deletar seu OS (pois quando restartar o container ele virá no mesmo formato de antes, que é o que foi colocado na imagem). <strong>Faça alguns testes aqui a seu prazer</strong>.</p>

<p>Para sair de dentro da imagem execute <code>exit</code>.</p>

<p>Vamos agora subir um container mais &ldquo;visual&rdquo;. Muitos estão falando sobre o Metabase, um visualizador gratuito. Então vamos subir uma aplicação em Foreground de Metabase para que possamos acessá-la.</p>

<pre><code class="language-sh">sudo docker run -p 8787:3000 metabase/metabase 
</code></pre>

<ul>
<li><p><code>-p</code>: Aqui temos um argumento novo, a porta. O app fica exposto numa porta, nesse caso na porta 3000. Porém essa porta é do contêiner e nós acessamos a máquina (host), então é necessário que seja construído um caminho para a porta do container. Então, quando se acessa <a href="http://127.0.0.1:8787/setup" target="_blank">http://127.0.0.1:8787/setup</a> você está acessando na verdade o contêiner na porta 3000. Caso você esteja em alguma instância o endereço seria <a href="http://ip-da-instancia:8787/setup" target="_blank">http://ip-da-instancia:8787/setup</a>. (porta do host à esquerda e do contêiner à direita)</p></li>

<li><p><code>metabase/metabase</code>: O nome da imagem, caso não tenha a imagem no PC o docker irá procurar em seu repositório</p></li>
</ul>

<p>Observe seu terminal, veja que ele está preso à aplicação, caso seu terminal morra a aplicação também irá sofrer o mesmo destino. Vamos subir a aplicação no modo detached.</p>

<p>Mas primeiro mate sua execução atual <code>CTRL + C</code>.</p>

<p>Agora sim, vamos subir no modo detached.</p>

<pre><code class="language-sh">sudo docker run -d -p 8787:3000 metabase/metabase 
</code></pre>

<p>Observe agora que o terminal está livre e a aplicação continua rodando. E agora que a imagem já está no PC, observe a velocidade que a aplicação entra em operação.</p>

<p>Podemos ainda fazer:</p>

<pre><code class="language-sh">sudo docker run  --rm -d -p 8787:3000 metabase/metabase 
</code></pre>

<ul>
<li><code>--rm</code>: Este argumento diz que, quando o container morrer ou ser parado, ele deve ser removido.</li>
</ul>

<p>O comando run tem muitas outras opções, como por exemplo dar acesso a pastas do host para o contêiner, declarar variáveis de ambiente, etc. Mas vamos deixar isso para depois, quando estivermos falando de docker-compose.</p>

<p><br><br></p>

<hr />

<h2 id="comandos-container">Comandos: container</h2>

<hr />

<p>O comando <code>container</code> nos permite verificar informações referentes aos containers. O container é a aplicação/imagem que foi executada ou está em execução.</p>

<p>Primeiramente vamos verificar os containers ativos, aquelas imagens que estão em execução.</p>

<pre><code class="language-sh">sudo docker container ls
</code></pre>

<ul>
<li><code>ls</code>: O argumento ls significa listar:</li>
</ul>

<p>Caso você tenha executado o exemplo detached do metabase da sessão anterior terá uma linha preenchida com as informações deste contêiner. Verá que ele está ativo, em qual porta, qual o comando executado e a quanto tempo.</p>

<p>Ao fazer:</p>

<pre><code class="language-sh">sudo docker container ls -a
</code></pre>

<ul>
<li><code>-a</code>: Este argumento representa &ldquo;all&rdquo;</li>
</ul>

<p>É possível ver todos os contêineres que já foram executados.</p>

<p>Vamos então matar esse container ativo que não mais necessitamos. Ao executar <code>sudo docker container ls</code> podemos ver os ativos, observe que, cada contêiner possui um CONTAINER ID, é por ele iremos matar o processo, basta fazer:</p>

<pre><code class="language-sh">sudo docker container kill CONTAINER_ID
</code></pre>

<p>No meu caso o comando foi <code>sudo docker container kill 816e65266526</code>, observe com <code>sudo docker container ls</code> que o contêiner não está mais de pé.</p>

<p>Há outros argumentos que podem ser utilizados junto com <code>container</code>, entre eles estão <code>exec</code>, <code>restart</code>, <code>pause</code>, <code>inspec</code>, <code>start</code>, <code>stop</code>, <code>unpause</code>, <code>logs</code>, etc. Normalmente eles estão ligados à manutenção de containers, sugiro que sejam estudados caso a necessidade (preciso visualizar as entranhas do meu container para observar algo, etc).</p>

<p><br><br></p>

<hr />

<h2 id="comandos-image">Comandos: image</h2>

<hr />

<p>Este comando tem o objetivo de gerir as imagens que existem. Inicialmente iremos utilizar bastante esse comando para poder baixar e subir imagens para o nosso repositório.</p>

<p>Vamos listar todas as imagens que estão salvas.</p>

<pre><code class="language-sh">sudo image ls -a
</code></pre>

<p>Observe os tamanhos de cada imagem, todas essas imagens estão salvas no HD. A medida que são utilizadas o espaço do HD vai diminuindo. Vamos deletar a imagem do ubuntu</p>

<pre><code class="language-sh">sudo docker rmi ubuntu
</code></pre>

<p>Caso tenha alguma imagem dependente da que iremos remover é necessário forçar a remoção</p>

<pre><code class="language-sh">sudo docker rmi -f ubuntu
</code></pre>

<p>Vamos baixá-la novamente.</p>

<pre><code class="language-sh">sudo docker image pull ubuntu
</code></pre>

<p>Falarei de como subir imagens somente após a construção da nossa primeira imagem.</p>

<p><br><br></p>

<hr />

<h2 id="comandos-prune">Comandos: prune</h2>

<hr />

<p>Este é um comando muito útil. Nós temos um histórico no docker, como por exemplo todos os contêineres já executados <code>sudo docker container ls -a</code>, e imagens que não mais utilizamos. O prune tem como objetivo limpar todos esse lixo. Ele pode ser feito em etapas ou em todo o docker. Vamos por etapas.</p>

<p><strong>Container:</strong></p>

<p>Veja quantos container que estão parados:</p>

<pre><code class="language-sh">sudo docker container ls -a
</code></pre>

<p>Podemos remover todos os containers parados com:</p>

<pre><code class="language-sh">sudo docker container prune
</code></pre>

<p>Podemos ainda filtrar, aqui removemos todos os container parados que possuem mais de 24 horas.</p>

<pre><code class="language-sh">sudo docker container prune --filter=&quot;until24h&quot;
</code></pre>

<p><strong>Images:</strong></p>

<p>Podemos remover imagens que são &ldquo;zumbis&rdquo;. Essas imagens são aquelas estão referenciadas por nenhum container ou imagem.</p>

<pre><code class="language-sh">sudo docker image prune
</code></pre>

<p>Podemos remover todas as imagens que não estejam associadas a um container:</p>

<pre><code class="language-sh">sudo docker image prune -a
</code></pre>

<p>E assim como no exemplo dos container podemos utilizar filtros</p>

<pre><code class="language-sh">sudo docker image prune --filter=&quot;until24h&quot;
</code></pre>

<p><strong>Tudo:</strong></p>

<p>Podemos fazer um prune de tudo ao mesmo tempo incluindo <strong>Networks (Não abordei Networks nesse documento, mas acho pertinente fazer uma pesquisa em separa quando ir surgindo a necessidade de ligar com essas configurações, mas num resumo bem breve, podemos criar Networks internas para os containers de modo que eles apenas se comuniquem num espaço fechado)</strong></p>

<pre><code class="language-sh">sudo docker system prune
</code></pre>

<p>Execute esse comando e depois observe quantos containers você possui e quantas imagens salvas.</p>

<p><br><br></p>

<hr />

<h2 id="comandos-build">Comandos: build</h2>

<hr />

<p><strong>VAMOS CONSTRUIR!!!!!</strong></p>

<p>Vamos construir nosso primeiro Dockerfile. O Dockerfile é uma receita de bolo, dizendo como será a imagem. Essa receita de bolo consiste em empilhar comandos do próprio Linux num arquivo interpretável. Existe um procedimento de como deixar as imagens menores e mais eficientes, mas isso não é importante no momento, apenas construa a seu prazer para testar as possibilidades.</p>

<p>O Dockerfile se baseia nos seguintes comandos:</p>

<ul>
<li><code>FROM</code>: A imagem inicial que sua imagem irá se basear (normalmente algo pequeno, para um ambiente de DEV costuma ser um OS e para produção um OS mais capado possível)</li>
<li><code>RUN</code>: Aqui dizemos os comandos que serão executados antes da imagem estar pronta (instalar pacotes por exemplo)</li>
<li><code>MAINTAINER</code>: O autor do arquivo</li>
<li><code>COPY</code>: Copia algum arquivo para dentro da imagem (assim quando a imagem for iniciada ela já possui o arquivo)</li>
<li><code>USER</code>: Define qual será o usuário padrão para a imagem</li>
<li><code>ENTRYPOINT</code>: Define qual a aplicação do container Normalmente é um arquivo em shell dentro da imagem com tudo para ser executado. É executado quanto a imagem é executada (na criação de um container).</li>
<li><code>CMD</code>: Semelhante ao ENTRYPOINT, pode executar um comando na execução da imagem, ou passar argumentos para o ENTRYPOINT. Porém o CMD pode ser &ldquo;ofuscado&rdquo; por algum outro comando na hora de executar a imagem, exemplo <code>sudo docker run --rm -it ubuntu /bin/bash</code>, aqui estamos executando a imagem ubuntu com o CMD <code>/bin/bash</code> que substitui qualquer outro CMD dentro da imagem.</li>
</ul>

<p>Vamos preparar o terreno. Primeiro precisamos de uma área de trabalho para essa imagem que vamos criar. Então vamos criar um caminho de pastas para nosso Dockerfile ficar isolado e entrar nessas pasta.</p>

<pre><code class="language-sh">mkdir teste_docker
cd teste_docker
</code></pre>

<ul>
<li><code>mkdir</code>: Significa &ldquo;make a directory&rdquo;, estamos criando uma pasta chamada teste_docker</li>
<li><code>cd</code>: Significa &ldquo;change directory&rdquo;, vamos entrar na pasta teste_docker.</li>
</ul>

<p>Estamos dentro da pasta de trabalho, agora iremos criar um arquivo de texto e começar a construir nossa imagem. Vamos utilizar o programa <code>nano</code>, caso não tenha instale:</p>

<p>Para CentOS</p>

<pre><code class="language-sh">sudo yum install nano
</code></pre>

<p>Para ubuntu/debian</p>

<pre><code class="language-sh">sudo apt-get install nano
</code></pre>

<p>Vamos criar um executável para passar para dentro da imagem.Observe que, após executar esse comando agora temos uma página em branco para ser preenchida. Para salvar o arquivo após algo escrito aperte CTRL+ O, para sair do editor nano e retornar ao terminal CTRL+X. Vamos preencher o documento.</p>

<pre><code class="language-sh">nano text_print.sh
</code></pre>

<p>Coloque o seguinte texto:</p>

<pre><code class="language-sh">
#!/usr/bin/env bash

echo &quot;ESTAMOS IMPRIMIIINDOO&quot;
</code></pre>

<p>Vamos criar um arquivo chamado Dockerfile:</p>

<pre><code class="language-sh">nano Dockerfile
</code></pre>

<p>Vamos colocar o seguinte texto:</p>

<pre><code class="language-sh">FROM ubuntu # da imagem ubuntu

MAINTAINER eu_mesmo # autor

RUN apt-get update \
    &amp;&amp; apt-get install -y mariadb-client \
    libmariadbclient-dev \
    libmariadb-client-lgpl-dev \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/* \
    &amp;&amp; rm -rf /tmp/*

COPY text_print.sh /text_print.sh

RUN chmod 755 /text_print.sh

ENTRYPOINT /text_print.sh
</code></pre>

<p>A seguir CTRL+O para salvar e CTRL+X para sair.</p>

<p>Acima temos:</p>

<ul>
<li>FROM: imagem ubuntu</li>
<li>MAINTAINER: autor</li>
<li>RUN: Executo uma série de comandos, primeiro dou update nos repositórios do apt-get (instalador de pacotes do ubuntu). Depois instalo 3 pacotes, cliente e bibliotecas do MariaDB. Após isso eu limpo o cache de instalação e deleto qualquer arquivo intermediário que possa ter ficado das instalações.</li>
<li>COPY: Copio o arquivo que criamos anteriormente e coloco na raiz</li>
<li>RUN: Dou permissão para esse arquivo ser executado
-ENTRYPOINT: Aponto o que será executado quando a subirmos o contêiner.</li>
</ul>

<p>Agora que temos a receita vamos construir a imagem &ldquo;buildar&rdquo;. A pasta deve conter apenas dois arquivos, verifique:</p>

<pre><code class="language-sh">ls
</code></pre>

<p>Deve retornar isso:</p>

<pre><code class="language-sh">Dockerfile  text_print.sh
</code></pre>

<p>Então vamos buildar a imagem:</p>

<pre><code class="language-sh">sudo docker build -t imagem_teste .
</code></pre>

<ul>
<li><code>build</code>: é o comando para construir a imagem</li>
<li><code>-t</code>: é o argumento dizendo que vamos nomear a nossa imagem</li>
<li><code>imagem_teste</code>: O nome da nossa imagem</li>
<li><code>.</code>: O comando build precisa que você referencie a pasta onde está o Dockerfile e os arquivos necessários para a construção. O <code>.</code> referencia a pasta que você está no presente momento com o console.</li>
</ul>

<p>Aguarde a imagem terminar de buildar e verifique:</p>

<pre><code class="language-sh">sudo docker image ls
</code></pre>

<p>Caso você tenha uma conta no docker hub (repositório oficial) ou tenha algum repositório de imagens configurado você pode fazer o seguinte para subir a imagem para tal.</p>

<pre><code class="language-sh">sudo docker tag imagem_teste seu_nome_usuario_repo/imagem_teste
sudo docker push seu_nome_usuario_repo/imagem_teste
</code></pre>

<p>Primeiro renomeia a imagem, colocando seu usuário como prefixo. Depois usar o push, para o upload da imagem, irá pedir um login e senha do repositório e irá iniciar o upload.</p>

<p>Vamos testar a imagem!!</p>

<pre><code class="language-sh">sudo docker run imagem_teste
</code></pre>

<p>Imprimiu o que queríamos?</p>

<p>Vamos sair desta pasta que criamos e voltar para onde estávamos</p>

<pre><code class="language-sh">cd ..
</code></pre>

<ul>
<li><code>..</code>: Este símbolo significa subir uma pasta</li>
</ul>

<p><br><br></p>

          </div>

          



          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Previous</div>
    <a href="/tutoriais/docker/docker_installation/" rel="next">Docker Installation</a>
  </div>
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Next</div>
    <a href="/tutoriais/docker/docker_compose/" rel="prev">Docker Compose</a>
  </div>
  
</div>

          </div>
          
        </div>

        <div class="body-footer">
          <p>Last updated on Aug 1, 2019</p>

          


          

        </div>

      </article>

      <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
  </p>
</footer>


    </main>
  </div>
</div>


      

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/r.min.js"></script>
        
      

      
      
    

    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.16bbb3750feb7244c9bc409a5a4fe678.js"></script>

    






  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
