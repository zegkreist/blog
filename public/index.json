[{"authors":["admin"],"categories":null,"content":"Navarro Rosa é um jovem estatístico que adora resolver problemas e responder perguntas usando dados. Já trabalhou com dados de notas fiscais de mais de um milhão de pessoas. Criando modelos para categorizar os produtos descritos nos cupons. Realizou análises de mercado e de cesta. Desenhou e aplicou testes A|B para verificar o efeito de campanha de marketing.\nHoje trabalha com dados de saúde. Fazendo modelos preditivos para doenças, chamando a atenção de médicos para os pacientes mais sérios. Testando a efetividade de programas médicos aplicado à populações.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Navarro Rosa é um jovem estatístico que adora resolver problemas e responder perguntas usando dados. Já trabalhou com dados de notas fiscais de mais de um milhão de pessoas. Criando modelos para categorizar os produtos descritos nos cupons. Realizou análises de mercado e de cesta. Desenhou e aplicou testes A|B para verificar o efeito de campanha de marketing.\nHoje trabalha com dados de saúde. Fazendo modelos preditivos para doenças, chamando a atenção de médicos para os pacientes mais sérios.","tags":null,"title":"Navarro Rosa","type":"authors"},{"authors":null,"categories":null,"content":"Tutorialzinho de Docker para dar um empurrão nos estudos, se você precisar é claro!\nAqui temos basicamente três sessões.\n Docker Installation: Faço um passo a passo de como instalhar o bagulho Docker Commands: Mostro os principais comandos Docker Compose: Mostro e exemplifico o docker-compose  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"2c26cbd1ed5aa1c685f844494d11f656","permalink":"/tutoriais/docker/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/tutoriais/docker/","section":"tutoriais","summary":"Aqui irei passar por alguns tópicos, como instalar o docker e docker-compose e como utilizá-los","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"Tutorialzinho de R para dar um empurrão inicial na manipulação de dados, se você precisar é claro!\nAqui temos basicamente duas sessões. Será acrescentado mais no futuro talvez próximo, talvez não.\n R basicão: Um overview do bagulho de modo geral, também ensina levantar um container de Rstudio Server.\n R Data Table: Ensinamentos básicos nos spells arcanos do Data Table. Manipulação de dados de uma forma eficiente em memória e rápido\u0026hellip; RÁPIDO\u0026hellip;\n  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"7f58cfa23a091138320da0fafef131ce","permalink":"/tutoriais/r_basico/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/tutoriais/r_basico/","section":"tutoriais","summary":"Aqui irei passar por alguns tópicos, como levantar uma imagem de RStudio server, objetos básicos do R, e opacotes absolutos para manipulação de dados.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":" R - Básico R em Container Agora que já se sabe como subir imagens de docker, vamos subir uma de R studio server com vários pacotes instalados para poder praticar.\nCASO NÃO QUEIRA PASSAR POR ISSO/ JÁ TEM UMA VERSÃO DO R INSTALADA E APENAS QUER VER UNS COMANDINHOS PULE PARA PROCESSA ETAMA (OLHE O TABLE OF CONTENTS DO LADO DIREITO)\nPrimeiro, vamos criar uma pasta de trabalho para o docker-compose.yml que iremos utilizar (assumindo que estamos num Linux, caso não esteja faça como achar melhor no seu sistema).\nmkdir /home/${USER}/docker_compose_rstudio  Vamos viajar lá para dentro.\ncd /home/${USER}/docker_compose_rstudio  Agora vamos criar uma pasta persistente para montarmos dentro do container. (Caso queira saber mais sobre isso olhe o tutorialzinho de docker que eu fiz, também aqui no VUGUDUM)\nmkdir /home/${USER}/Projetos_R  Criar um arquivo docker-compose.yml já com tudo dentro (Coloque uma senha melhor para sua pessoa). Esta imagem zegkreist/r-dl-cpu foi criada por mim, ela possui quase tudo que um cientista de dados precisa (por isso ela é gigante ~ 9GB, caso queira outra com RStudio se sinta tranquilo para fazer o que você \u0026ldquo;querÊ\u0026rdquo;)\necho \u0026quot; version: '2' services: r-dl-cpu_teste: image: zegkreist/r-dl-cpu container_name: r_server_1 restart: always environment: - USER=$USER - USERID=1000 - PASSWORD=123facil ports: - \u0026quot;8787:8787\u0026quot; volumes: - /home/${USER}/Projetos_R:/home/teste/Projetos_R:rw \u0026quot; \u0026gt; /home/${USER}/docker_compose_rstudio/docker-compose.yml  Suba o serviço do rstudio server utilizando o docker-compose\ndocker-compose up -d  Acesse em http://127.0.0.1:8787 se for na sua máquina local ou http://ip_da_sua_instancia:8787. O login será seu usuário (rode echo $USER no console para descobrir) e a senha será a que você escolheu. Caso esteja numa instância remota que fique claro que a conexão aqui é apenas HTTP, para transforma-la em HTTPS precisa fazer um rolê aí que não irei explicar aqui, pois não é o foco.\nSua pessoa chegará numa tela parecida com essa.\nObserve que há 4 áreas principais\n Source: onde está o editor de códigos e arquivos txt Environment/History/Conn/Git: Onde mostra os objetos declarados (há também outras abas, como history dos comandos rodados, connections, git, etc) Console: Onde os script são executados (há também outras abas, como terminal em que você pode executar comandos no console do seu OS, como estamos dentro de um serviço em container este terminal é sobre o OS do container, um Debian) Files/Packages/Plot/Help: Aqui está uma espécie de \u0026lsquo;navegador\u0026rsquo;, você pode olhar os arquivos nas pastas vizinhas, olhar as figuras geradas pelo R, usar o Help para pesquisa de comandos, etc.  Antes de começarmos a praticar vamos criar um projeto. Um projeto no R possui um work directory, seta o \u0026ldquo;home\u0026rdquo; do projeto como este work directory, salva o histórico de códigos rodados neste projeto, facilita commit utilizando o git, assim como o push para o repositório. Então, SEMPRE faça as coisas dentro de um projeto, melhor organização .. melhor código.\nVamos criar uma pasta para o projeto, navegue para dentro da pasta Projetos_R clique em New Folder e crie uma nova paste com o nome do projeto, pode ser inicio.\nAgora vamos criar um novo projeto nesta pasta, para isso vá no canto direito superior em:\nClique em diretório já existente e selecione a pasta E CRIE SEU PROJETOOO!\nPronto, estamos dentro de um projeto mais organizado e controlado, todo script que salvar será nessa sua pasta criada. Vamos iniciar um novo script, no canto esquerdo superior há um sinal de positivo em verde sobre uma folha branca, clique nele e vá em Rscript.\nAgora podemos começar a brincar com o R!!!!\nObjetos O R é uma linguagem funcional, tudo e qualquer coisa no R é uma chamada de função, porém algumas coisas podem ser vistas como objetos, são elas:\n Vetor Matriz Data-frame Lista  Há pacotes que possuem versões alternativas desses objetos como veremos mais a frente, mas veremos o que está no base por enquanto.\nVetores O vetor é um array de uma dimensão, ou uma matriz \\(1 \\times n\\). Há várias formas de declarar um vetor. Podemos declarar numeric, integer, character, date, int64, etc, veja algumas delas:\nDiretamente.\na \u0026lt;- c(1,2,3,4) a  ## [1] 1 2 3 4  Usando uma sequência que pula de um em um.\na \u0026lt;- 1:4 a  ## [1] 1 2 3 4  Usando a função de sequência informando a quantidade que deve ser pulado.\na \u0026lt;- seq(1, 4, by = 1) a  ## [1] 1 2 3 4  Usando uma função que repete um determinado valor \\(n\\) vezes.\na \u0026lt;- rep(1, 10) a  ## [1] 1 1 1 1 1 1 1 1 1 1  b \u0026lt;- rep(\u0026quot;eita\u0026quot;, 3) b  ## [1] \u0026quot;eita\u0026quot; \u0026quot;eita\u0026quot; \u0026quot;eita\u0026quot;  A primeira posição do vetor é 1 e usamos a função [.\na \u0026lt;- 1:10 #primeira posicao a[1]  ## [1] 1  #ultima posicao a[length(a)]  ## [1] 10  #as primeiras 4 posicoes a[1:4]  ## [1] 1 2 3 4  b \u0026lt;- LETTERS b[1:10]  ## [1] \u0026quot;A\u0026quot; \u0026quot;B\u0026quot; \u0026quot;C\u0026quot; \u0026quot;D\u0026quot; \u0026quot;E\u0026quot; \u0026quot;F\u0026quot; \u0026quot;G\u0026quot; \u0026quot;H\u0026quot; \u0026quot;I\u0026quot; \u0026quot;J\u0026quot;  #output de length(a) length(a)  ## [1] 10  Matrizes Assim como no C++ uma matriz pode ser vista como um vetor de vetores de mesmo tamanho. No R a matriz deve ser apenas de um tipo, ou seja, todas as colunas devem ser do mesmo tipo, como numeric, character, etc. Para declarar uma matriz primeiro e necessário declarar um vetor e reposicioná-lo com a função matrix. Por exemplo:\nvetor_inicial \u0026lt;- 1:9 matriz \u0026lt;- matrix(data = vetor_inicial, ncol = 3, byrow = T ) matriz  ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9   data: Informo o vetor que será reposicionado ncol: informo quantas colunas a matriz terá byrow: informo como será a distribuição  Se fizermos com byrow = F temos:\nmatriz \u0026lt;- matrix(data = vetor_inicial, ncol = 3, byrow = F ) matriz  ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9  Para sabermos a dimensão da matriz basta utilizar dim(matriz). O modo de acesso é semelhante ao vetor, utilizando a função [.\n#primeira posicao matriz[1,1]  ## [1] 1  #segunda posicao matriz[1,2]  ## [1] 4  #primeira linha matriz[1,]  ## [1] 1 4 7  #primeira coluna matriz[,1]  ## [1] 1 2 3  Podemos ainda nomear as colunas ou linhas e chamá-las pelo nome, veja:\ncolnames(matriz) \u0026lt;- c(\u0026quot;primeira\u0026quot;, \u0026quot;segunda\u0026quot;, \u0026quot;terceira\u0026quot;) matriz[,\u0026quot;primeira\u0026quot;]  ## [1] 1 2 3  #ou ainda um conjunto de colunas matriz[, c(\u0026quot;primeira\u0026quot;, \u0026quot;segunda\u0026quot;)]  ## primeira segunda ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6  Repare que, eu declarei um vetor de nomes c(\u0026quot;primeira\u0026quot;, \u0026quot;segunda\u0026quot;) dentro do local de definição das colunas, eu poderia ter feito anteriormente, veja:\nsubset_c \u0026lt;- c(\u0026quot;primeira\u0026quot;, \u0026quot;segunda\u0026quot;) matriz[, subset_c]  ## primeira segunda ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6  Data-frame O data-frame é um \u0026lsquo;objeto\u0026rsquo; semelhante à uma matriz, porém necessita de ter as colunas nomeadas. Cada coluna é um vetor independente do outro, podendo assim ser de tipos diferentes. Há também formas diferentes de acesso ao data-frame.\nVamos declarar um data-frame para podermos explorá-lo.\ndados \u0026lt;- data.frame(id = 1:10, #integer letras = LETTERS[1:10], #character factor numeros = runif(n = 10, min = 1, max = 100) #numeric ) head(dados)  ## id letras numeros ## 1 1 A 98.08171 ## 2 2 B 43.00829 ## 3 3 C 26.86298 ## 4 4 D 40.94583 ## 5 5 E 16.11603 ## 6 6 F 48.42628  Podemos acessar o data-frame de forma semelhante à matriz, veja:\ndados[1,] # Primeira linha  ## id letras numeros ## 1 1 A 98.08171  dados[,1] # Primeira coluna  ## [1] 1 2 3 4 5 6 7 8 9 10  dados[, \u0026quot;letras\u0026quot;] #coluna letras  ## [1] A B C D E F G H I J ## Levels: A B C D E F G H I J  #podemos acessar ainda utilizando o operador $, veja: dados$letras # Desta forma acessamos o vetor diretamente  ## [1] A B C D E F G H I J ## Levels: A B C D E F G H I J  Listas As listas são contêineres que podem guardar qualquer tipo de objeto do R em seus slots, seria quase uma espécie de JSON (ou map em outras linguagens). Veja a seguinte declaração:\nlista \u0026lt;- list( primeira_pos = 1:3, segunda_pos = data.frame(col_1 = 1:10), terceira_pos = list( inception = \u0026quot;YEAH\u0026quot; ) )  Vamos acessar seus conteúdos. Basicamente utilizaremos a função [[ e o operador (que também é uma função) $.\nlista[\u0026quot;primeira_pos\u0026quot;]  ## $primeira_pos ## [1] 1 2 3  # os seguintes abaixo sao equivalentes lista[[1]] # vetor de fato  ## [1] 1 2 3  lista$primeira_pos # vetor de fato  ## [1] 1 2 3  Agora, navegando pelo data.frame da segunda posição.\n#acessando primeira coluna do data.frame armazenado na lista lista[[2]]$col_1  ## [1] 1 2 3 4 5 6 7 8 9 10  lista[[\u0026quot;segunda_pos\u0026quot;]]# data.frame  ## col_1 ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 ## 7 7 ## 8 8 ## 9 9 ## 10 10  lista$segunda_pos # data.frame  ## col_1 ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 ## 7 7 ## 8 8 ## 9 9 ## 10 10  lista$segunda_pos$col_1 # primeira coluna do data.frame  ## [1] 1 2 3 4 5 6 7 8 9 10  lista$segunda_pos$col_1 # primeira coluna do data.frame  ## [1] 1 2 3 4 5 6 7 8 9 10  Agora acessando a lista dentro da lista.\nlista$terceira_pos # lista segundo nivel  ## $inception ## [1] \u0026quot;YEAH\u0026quot;  lista[[\u0026quot;terceira_pos\u0026quot;]][[\u0026quot;inception\u0026quot;]] # resultado da lista segundo nivel  ## [1] \u0026quot;YEAH\u0026quot;  lista[[\u0026quot;terceira_pos\u0026quot;]]$inception # resultado da lista segundo nivel  ## [1] \u0026quot;YEAH\u0026quot;  lista$terceira_pos$inception # resultado da lista segundo nivel  ## [1] \u0026quot;YEAH\u0026quot;  Tipos No R temos basicamente numeric (seria um float), integer, character, factor (um tipo especial de character), posix/ date (um tipo especial de character), logical, complex. Existem alguns pacotes do R que expandem os tipos, adicionando coisas como int64 por exemplo. Com a função class é possível observar o tipo de variáveis, vejamos alguns exemplos:\nrequire(lubridate) # pacote que adiciona tipo date  ## Loading required package: lubridate  ## ## Attaching package: 'lubridate'  ## The following object is masked from 'package:base': ## ## date  a \u0026lt;- .1 b \u0026lt;- 1L c \u0026lt;- 'eita' d \u0026lt;- \u0026quot;Eita\u0026quot; e \u0026lt;- factor(c('a','b',\u0026quot;c\u0026quot;,\u0026quot;D\u0026quot;)) f \u0026lt;- Sys.time() g \u0026lt;- 1+1i h \u0026lt;- c(T,F, TRUE, FALSE) i \u0026lt;- c(1,2,\u0026quot;a\u0026quot;,T) # CUIDADO PARA NÃO MISTURAR OS TIPOS j \u0026lt;- c(1,2,T,F) # CUIDADO PARA NÃO MISTURAR OS TIPOS l \u0026lt;- lubridate::as_date(Sys.time()) cat(paste0(c(\u0026quot;Tipo: a \u0026quot;, class(a), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: b \u0026quot;, class(b), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: c \u0026quot;, class(c), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: d \u0026quot;, class(d), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: e \u0026quot;, class(e), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: f \u0026quot;, class(f), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: g \u0026quot;, class(g), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: h \u0026quot;, class(h), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: i \u0026quot;, class(i), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: j \u0026quot;, class(j), \u0026quot;\\n\u0026quot;, \u0026quot;Tipo: l \u0026quot;, class(l), \u0026quot;\\n\u0026quot; ), collapse = \u0026quot; \u0026quot; ) )  ## Tipo: a numeric ## Tipo: b integer ## Tipo: c character ## Tipo: d character ## Tipo: e factor ## Tipo: f POSIXct POSIXt ## Tipo: g complex ## Tipo: h logical ## Tipo: i character ## Tipo: j numeric ## Tipo: l Date  Operações No R podemos fazer as operações básicas +-*/^, mas também há outras como %*%, %% e %in% e até mesmo filtros (que aqui estou chamando de operações).\nOs seguintes +-*/^ tem caráter de operação escalar, veja os exemplos:\na \u0026lt;- c(1,2,3,4) b \u0026lt;- c(2,2,2,2) 1+1 # escalar  ## [1] 2  10*5 # escalar  ## [1] 50  2^4 #escalar  ## [1] 16  a*2 # escalar  ## [1] 2 4 6 8  a/2 # escalar  ## [1] 0.5 1.0 1.5 2.0  a^2 # escalar  ## [1] 1 4 9 16  a*b #escalar  ## [1] 2 4 6 8  a+b #escalar  ## [1] 3 4 5 6  a^2 # escalar  ## [1] 1 4 9 16  O operador %% é o resto de uma divisão, e %/% a parte inteira de uma divisão, então:\n4%%3  ## [1] 1  4%%2  ## [1] 0  7%/%2  ## [1] 3  10%/%2  ## [1] 5  O operador %*% é a multiplicação de matrizes.\nA \u0026lt;- matrix(c(1:9), ncol = 3, byrow = T) B \u0026lt;- matrix(c(1:9), ncol = 3, byrow = F) A%*%B # Multiplicacao de matriz  ## [,1] [,2] [,3] ## [1,] 14 32 50 ## [2,] 32 77 122 ## [3,] 50 122 194  A+B # soma escalar  ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 6 10 14 ## [3,] 10 14 18  A*B # multiplicacao escalar  ## [,1] [,2] [,3] ## [1,] 1 8 21 ## [2,] 8 25 48 ## [3,] 21 48 81  A^2 # potencia escalar  ## [,1] [,2] [,3] ## [1,] 1 4 9 ## [2,] 16 25 36 ## [3,] 49 64 81  A%*%A #potencia matricial  ## [,1] [,2] [,3] ## [1,] 30 36 42 ## [2,] 66 81 96 ## [3,] 102 126 150  HAIL to all mighty PIPE O R possui um operador peculiar provindo de um pacote chamado magrittr. Ele oferece uma facilidade viciante, por isso ficou tão popular que é comum quando um novo pacote está sendo feito para o R os autores implementam as features necessárias para que o pipe também seja utilizado em conjunto com suas funções. Como dito anteriormente, tudo no R é uma função, e estas funções podem ser redefinidas, podemos inclusive trocar os significados dos operados +-*/, mas isto seria besteira.\nO pipe é um operador que faz o seguinte: lhs %\u0026gt;% lhs, seu comportamento é passar o lhs para ser avaliado em lhs. Então, seja x algum objeto e foo uma função, assim x %\u0026gt;% f é equivalente a f(x). Caso f necessite múltiplos argumentos, o comportamento padrão é que o objeto x seja colocado na primeira posição de f, ou seja, x %\u0026gt;% f(y) é equivalente a f(x,y). Podemos escolher a posição que será inserido da seguinte forma x %\u0026gt;% f(y, .) é equivalente a f(y,x).\nMas por que o pipe é tão utilizado? Imagine que tenhamos um objeto xe necessitamos de fazer várias operações encadeadas, o pipe permite que o código fique mais organizado. EXEMPLO:\nVamos criar um vetor x, calcular seu comprimento e calcular a média de uma amostra aleatória de mesmo tamanho. É um exemplo bobo, mas já ilustra o potencial da criança.\nx \u0026lt;- 1:100 #modo 1 n \u0026lt;- length(x) result \u0026lt;- sample(1000, size = n) result \u0026lt;- mean(result) #modo 2 result \u0026lt;- sample(1000, size = length(x)) result \u0026lt;- mean(result) #modo 3 result \u0026lt;- mean(sample(1000, size = length(x))) # THE KING result \u0026lt;- x %\u0026gt;% length() %\u0026gt;% sample(1000, size = .) %\u0026gt;% mean()  Observe que utilizando o pipe, o código basicamente vira um bullet de uma apresentação de slide, a leitura é direta. Vou colocar um exemplo de código aqui embaixo, veja que não explicarei nada do código, esta apostila é para iniciante na linguagem (então suponho que não está familiarizado com o R) e mesmo assim terá uma capacidade alta de compreensão do que está sendo feito.\nSeja dados um conjunto de dados qualquer.\nresult \u0026lt;- dados %\u0026gt;% dplyr::filter(ano \u0026gt;= \u0026quot;2018-01-01\u0026quot;) %\u0026gt;% dplyr::group_by(CodProcedimento) %\u0026gt;% dplyr::summarise(media = mean(ValorUtilizacao))  Apenas leia, é literalmente uma receita de bolo.\n Pegue dados\n Filtre para ano \u0026gt;= \u0026ldquo;2018-01-01\u0026rdquo;\n Agrupe por CodProcedimento\n Calcule a média do Valor Utilização\n  Vamos reescrever isso de um jeito nojento.\nresult \u0026lt;- dplyr::summarise(dplyr::group_by(dplyr::filter(dados, ano \u0026gt;= \u0026quot;2018-01-01\u0026quot;), CodProcedimento), media = mean(ValorUtilizacao) )  É bem fácil de entender até a parte do dplyr::summarise, depois disso\u0026hellip;\nPorém não iremos utilizar o pacote dplyr para fazer manipulações, é bonitinho porém não performa bem.\nFiltros e subsets No R devemos evitar o máximo possível fazer laços (for ou while). Temos outras ferramentas para busca e para aplicar funções repetidamente, como as funções da família apply.\nAbaixo mostrarei como fazer subsets e filtros.\nImage que tenhamos um vetor que gostaríamos de selecionar todos os número maior que um threshold. Podemos utilizar vetores lógicos para fazer essa seleção. Primeiro, vamos demonstrar a criação de um vetor lógico.\nSuponha o seguinte vetor:\na \u0026lt;- runif(20,1,10)  Podemos criar um vetor lógico indicador, vamos supor que gostaríamos de marcar todo número menor que 5.\nvetor_logico \u0026lt;- a \u0026lt; 5 vetor_logico  ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE ## [12] TRUE TRUE TRUE FALSE TRUE TRUE FALSE FALSE TRUE  Agora podemos selecionar posições em a informando quem \u0026lsquo;desligar\u0026rsquo; e a quem retornar, veja:\na[vetor_logico]  ## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133 ## [9] 2.706487  # podemos escrever diretamente a[a \u0026lt; 5] # quero a, onde a é menor que 5  ## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133 ## [9] 2.706487  Agora queremos as posições de a que são menores que 5\nwhich(a \u0026lt; 5 )  ## [1] 5 10 11 12 13 14 16 17 20  pos \u0026lt;- which(a \u0026lt; 5) a[pos]  ## [1] 1.032027 4.410348 4.270202 2.854233 4.884520 3.757685 3.068622 3.834133 ## [9] 2.706487  Podemos também negar um vetor lógico (basicamente pegando o contrário)\na[!vetor_logico]  ## [1] 6.385984 8.736175 7.104037 8.203882 6.494243 6.770594 9.450312 ## [8] 6.899342 7.313048 7.928868 7.744817  Os vetores lógicos possuem algumas propriedades, por exemplo TRUE = 1 e FALSE = 0, então podemos fazer operações com isso. Queremos saber quantos números em a são menores que 5, então podemos fazer assim:\nsum(a \u0026lt; 5)  ## [1] 9  # ou assim length(a[a \u0026lt; 5])  ## [1] 9  Vamos zerar os números menores que 5:\na*!vetor_logico  ## [1] 6.385984 8.736175 7.104037 8.203882 0.000000 6.494243 6.770594 ## [8] 9.450312 6.899342 0.000000 0.000000 0.000000 0.000000 0.000000 ## [15] 7.313048 0.000000 0.000000 7.928868 7.744817 0.000000  # ou podemos trocar no proprio objeto a[a \u0026lt; 5] \u0026lt;- 0 a  ## [1] 6.385984 8.736175 7.104037 8.203882 0.000000 6.494243 6.770594 ## [8] 9.450312 6.899342 0.000000 0.000000 0.000000 0.000000 0.000000 ## [15] 7.313048 0.000000 0.000000 7.928868 7.744817 0.000000  Podemos utilizar outros vetores de mesmo tamanho para fazer esse filtro, caso as informações sejam casadas. Vamos supor um data.frame e trabalhar com ele para esses filtros\ndados \u0026lt;- data.frame(id = 1:20, #integer letras = LETTERS[1:20], #character factor numeros = runif(n = 20, min = 1, max = 100) #numeric )  Queremos as letras da coluna letras que possuam um número da coluna numeros menor que 50.\ndados$letras[dados$numeros \u0026lt; 50]  ## [1] B D E F G H K N O P R S T ## Levels: A B C D E F G H I J K L M N O P Q R S T  Podemos definir um outro data.frame com esse filtro\ndados1 \u0026lt;- dados[dados$numeros \u0026lt; 50, ] head(dados1)  ## id letras numeros ## 2 2 B 1.518690 ## 4 4 D 3.384159 ## 5 5 E 23.287412 ## 6 6 F 28.360873 ## 7 7 G 9.157979 ## 8 8 H 41.689610  Nós usamos muito os vetores lógicos, em todos os lugares. Porém não vou me prolongar aqui, farei isso quando estivermos falando de data.table que é redesenho do data.frame. É utilizando ele que faremos todas as manipulações alá banco de dados, por que ele? por isso:\nMáquina do benchmark.\nIntel\u0026reg; Xeon\u0026reg; CPU E5-2660 v3 @ 2.60GHz\n20 CPU CORE\n125.8 GB RAM\n\nLaços Como disse antes, é bom que evitemos laços ao máximo, mas há momentos que não tem tal possibilidade. Utilizando as funções da família apply podemos substitui praticamente qualquer laço sem o overhead gigantesco (se comparado a outras linguagens) que ele causa. Porém o código fica confuso, é mais complicado pensar na arquitetura da operação, etc. Então há lugares que de fato é proveitoso usar um laço, normalmente quando os planetas se alinham da seguinte forma:\n O passeio é curto: quando é necessário poucas iterações ( menor que 1000).\n A carga é pesada: quando o que se calcula no seu interior é pesado a tal ponto que o overhead gerado pelo loop em si seja irrelevante.\n  Por que o número 1000 em poucas iterações? Normalmente quando se precisa de mais iterações do que isso significa que o processo interno é leve, feito em batchs, há outras formas ( e muito melhores) para se lidar com isso do que um loop. Sua pessoa deve usar e abusar da vetorização que o R oferece. Sempre que criar uma função, pense em aplicá-la para o vetor ou matriz inteira e não de forma escalar.\nFor O exemplo que usarei aqui é simples, lembre-se que contas leves não deve ser feito num loop.\nresult \u0026lt;- numeric(20) # sempre que possível pre aloque o vetor de resultados for(i in 1:20){ result[i] \u0026lt;- i^2 } result  ## [1] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 ## [18] 324 361 400  Vamos testar uns tempos?\nrbenchmark::benchmark( \u0026quot;sem_alocar\u0026quot; = { result \u0026lt;- c() for(i in 1:2000){ result[i] \u0026lt;- i^2 } }, \u0026quot;pre_alocado\u0026quot; = { result \u0026lt;- numeric(2000) # sempre que possível pre aloque o vetor de resultados for(i in 1:2000){ result[i] \u0026lt;- i^2 } }, \u0026quot;vetorizado\u0026quot; ={ (1:2000)^2 }, order = \u0026quot;relative\u0026quot;, replications = 100, columns = c(\u0026quot;test\u0026quot;, \u0026quot;replications\u0026quot;, \u0026quot;relative\u0026quot;, \u0026quot;elapsed\u0026quot;) )  ## test replications relative elapsed ## 3 vetorizado 100 1 0.001 ## 2 pre_alocado 100 240 0.240 ## 1 sem_alocar 100 273 0.273  Observe a velocidade relativa, o método vetorizado é a base, observe que o método sem_alocar é o mais demorado, quantas vezes mais lento? Muito não?!? Agora observe que caso o tamanho do result seja pré alocado é um pouco mais rápido, mas nem de longe comparado com a versão vetorizada.\nTemos também as condições que podem ser inseridas num for para quando satisfeita alguma condição específica:\n break: Para o loop, saindo dele\n next: Pula essa iteração indo para a próxima\n  While Particularmente acho que da para contar nos dedos de uma mão as vezes em que utilizei o while, acredito que apenas em simulações, esperando algo convergir, etc. Segue o exemplo:\nresult \u0026lt;- numeric(20) i \u0026lt;- 1 while(i \u0026lt;= 20){ result[i] \u0026lt;- i i \u0026lt;- i+1 }  As condições nexte break também funcionam para o while.\nIF \u0026hellip; or ELSE!! A lógica para esses caras é como para qualquer outra linguagem, tem apenas um porém em relação à uma função em específico ifelse que pode facilitar algumas coisas.\nA estrutura se inicia por um if com uma determinada condição e logo depois um else opcional. Lembrando que esta condição deve ter comprimento 1, não podendo ser um vetor lógico.\na \u0026lt;- 1 if(a == 1){ \u0026quot;EITA PORRA\u0026quot; }else{ \u0026quot;Eita nada\u0026quot; }  ## [1] \u0026quot;EITA PORRA\u0026quot;  a \u0026lt;- 0 if(a == 1){ \u0026quot;EITA PORRA\u0026quot; }else{ \u0026quot;Eita nada\u0026quot; }  ## [1] \u0026quot;Eita nada\u0026quot;  a \u0026lt;- 0 if(a != 1){ \u0026quot;EITA PORRA\u0026quot; }  ## [1] \u0026quot;EITA PORRA\u0026quot;  a \u0026lt;- 0 if(a \u0026gt; 1){ \u0026quot;EITA PORRA\u0026quot; } # nao retorna nada  A função ifelse permite ser aplicada num vetor lógico.\na \u0026lt;- c(T,T,F,T,F,F) result \u0026lt;- ifelse(test = a, yes = \u0026quot;EITAAAA\u0026quot;, no = \u0026quot;EITA NAAOO\u0026quot; ) result  ## [1] \u0026quot;EITAAAA\u0026quot; \u0026quot;EITAAAA\u0026quot; \u0026quot;EITA NAAOO\u0026quot; \u0026quot;EITAAAA\u0026quot; \u0026quot;EITA NAAOO\u0026quot; ## [6] \u0026quot;EITA NAAOO\u0026quot;  Onde o test é uma condição ou um vetor de condições, como embaixo:\na \u0026lt;- runif(10,1,10) result \u0026lt;- ifelse(test = a \u0026lt; 5, yes = \u0026quot;EITAAAA\u0026quot;, no = \u0026quot;EITA NAAOO\u0026quot; ) dados \u0026lt;- data.frame(A = a, condicoes = a \u0026lt; 5, saida = result ) dados  ## A condicoes saida ## 1 7.588302 FALSE EITA NAAOO ## 2 5.560936 FALSE EITA NAAOO ## 3 4.385240 TRUE EITAAAA ## 4 2.665477 TRUE EITAAAA ## 5 2.307467 TRUE EITAAAA ## 6 2.449290 TRUE EITAAAA ## 7 2.920070 TRUE EITAAAA ## 8 8.914990 FALSE EITA NAAOO ## 9 3.729306 TRUE EITAAAA ## 10 4.224658 TRUE EITAAAA  Funções No R tudo são funções, então também temos que fazer nossas próprias funções. Para declarar uma função podemos deixar sem argumentos ou quantos quisermos. Eles podem ter valores default ou não. O ultimo valor a ser retornado que a função irá retornar\nfoo \u0026lt;- function(){ \u0026quot;eita\u0026quot; } foo1 \u0026lt;- function(){ \u0026quot;eita\u0026quot; \u0026quot;eita_porra\u0026quot; } foo()  ## [1] \u0026quot;eita\u0026quot;  foo1()  ## [1] \u0026quot;eita_porra\u0026quot;  Ou ainda podemos deixar explicitado o que será retornado:\nfoo2 \u0026lt;- function(){ \u0026quot;eita\u0026quot; \u0026quot;eita_porra\u0026quot; return(\u0026quot;isso aqui sera retornado\u0026quot;) } foo2()  ## [1] \u0026quot;isso aqui sera retornado\u0026quot;  Vamos colocar um argumento e com alguma \u0026ldquo;mastigação\u0026rdquo;:\nfoo3 \u0026lt;- function(argumento){ result \u0026lt;- paste0(\u0026quot;Mastigando: \u0026quot;, argumento) return(result) } foo3(argumento = \u0026quot;E I T A !1\u0026quot;)  ## [1] \u0026quot;Mastigando: E I T A !1\u0026quot;  Mas se tentarmos rodar sem especificar um argumento um erro é retornado. Tente rodar o seguinte comando no seu console.\nfoo3()  Podemos definir um valor default para este argumento:\nfoo4 \u0026lt;- function(argumento = \u0026quot;Valor Default\u0026quot;){ result \u0026lt;- paste0(\u0026quot;Mastigando: \u0026quot;, argumento) return(result) } foo4()  ## [1] \u0026quot;Mastigando: Valor Default\u0026quot;  NÃO RECOMENDO, mas podemos utilizar uma função para alterar um valor no enviroment global do R. Semelhante a usar uma função que retorna void no c++ e usar ponteiros para alterar informações \u0026ldquo;in place\u0026rdquo;.\na \u0026lt;- 1:10 foo5 \u0026lt;- function(){ a[a \u0026lt; 5] \u0026lt;\u0026lt;- 100 }  Veja o vetor a como ele é:\na  ## [1] 1 2 3 4 5 6 7 8 9 10  Vamos rodar a função que modifica inplace por referência.\nfoo5()  Agora vejamos a novamente.\na  ## [1] 100 100 100 100 5 6 7 8 9 10  Loading |======\u0026mdash;| 75% Dados, vamos aprender a carregar dados. O R tem vários pacotes que nos permitem carregar praticamente qualquer tipo de dado, JSON, csv, txt, Rdata, RDS, até aqueles vindo de programas como excel, stata, access, SPSS, etc. Basta procurar, porém inicialmente nos preocupemos apenas com arquivos csv/txt e dados provindo de bancos.\nCSV e TXT Temos uma função milagrosa que consegue fazer o parse do arquivo texto e carregar em velocidades astronômicas, esta função também é proveniente do nosso querido e amado data.table. Ele também fornece uma função estupidamente rápida para escrever esses dados em csv ou txt.\nVamos primeiro criar um arquivo txt para podermos treinar os carregamentos, isto implica que primeiro iremos aprender a escrever para depois ler. Já vamos iniciando no data.table.\nlibrary(data.table) # No R devemos carregar as bibliotecas que iremos utilizar previamente  ## ## Attaching package: 'data.table'  ## The following objects are masked from 'package:lubridate': ## ## hour, isoweek, mday, minute, month, quarter, second, wday, ## week, yday, year  ##### # Observe que, além de ter carregado a blibioteca, # eu tambem indiquei na funcao abaixo de qual biblioteca ela provem (utilizando data.table:: antes da funcao) # este e um passo opcional, mas acredito que para um codigo em producao isso deve ser feito ##### dados \u0026lt;- data.table::data.table(id = 1:50000, numeros = runif(50000, 1, 100), letras = sample(LETTERS, 50000, replace = T) ) ## vamos escrever data.table::fwrite(dados, \u0026quot;dados_example.txt\u0026quot;) ## Vamos rodar um comando no bash do linux para compactar o arquivo system(\u0026quot;gzip \u0026lt; dados_example.txt \u0026gt; dados_example.txt.gz\u0026quot;)  A função fwrite se diz respeito à escrita de um arquivo texto no filesystem. Estou utilizando as configurações default, em que basicamente seleciona-se separador de campos como vírgula, strings que possuem o separador contido nelas estão entre aspas, e a primeira linha se trata do nome das colunas.\nExplicando a compressão. A função system executa a string no console bash do linux. O que lemos nessa string? Eu aponto o arquivo .txt para o programa gzip da seguinte forma gzip \u0026lt; dados_example.txt e pego o resultado disso e coloco para o arquivo dados_example.txt.gz usando o apontamento \u0026gt;\nVamos verificar os tamanhos dos arquivos.\nfile.size(\u0026quot;dados_example.txt.gz\u0026quot;)/1000000 #mb  ## [1] 0.586925  file.size(\u0026quot;dados_example.txt\u0026quot;)/1000000 #mb  ## [1] 1.233302  Vamos carregar o arquivo original utilizando a função fread do data.table.\ndados \u0026lt;- data.table::fread(\u0026quot;dados_example.txt\u0026quot;)  Carregando pelo arquivo comprimido\ndados \u0026lt;- data.table::fread(\u0026quot;zcat dados_example.txt.gz\u0026quot;)  A função fread faz o parse automático do arquivo. Porém é possível adicionar argumentos a mais como qual string é responsável pela separação sep, qual o padrão de decimal utilizado no arquivo dec, e inúmeros outros. Para ver todos os argumentos procure pelo nome da função na aba de help do canto direito da IDE do Rstudio.\nLeitura do banco de dados Para se ler do banco de dados é necessário primeiramente criar uma conexão com o banco. Esta conexão pode ser feita de várias formas diferentes e cada banco de dados possui uma forma diferente. Para o SQL SERVER utilizaremos o driver ODBC oficial da Microsoft (que já se encontra nessa imagem de docker). Porém não temos um banco de testes aqui, farei um exemplo se conectando ao MySQL de um dos nosso servidores (mas mostrando um código dummy).\nÉ necessário a criação de um objeto de conexão com o banco. Este objeto pode ser criado por inúmeros pacotes diferentes, aqui irei utilizar uma combinação do pacote DBI e RMariaDB. O MariaDB é um fork do próprio MySQL, dos mesmos criadores, que ocorreu quando este foi comprado. O conector do RMariaDB é eficiente e funciona bem com o MySQL.\n## Carregando pacotes necessarios library(DBI) library(RMariaDB) ## Criando objeto de conexao con \u0026lt;- DBI::dbConnect(RMariaDB::MariaDB(), user='SUPER USUARIO', password='SENHA FODA BAGARAI', #dbname= database., dbname='DW_name_cliente', host='192.168.134.63', encoding = \u0026quot;latin1\u0026quot;, bigint = \u0026quot;character\u0026quot; )  Agora que temos o objeto de conexão con, iremos utilizá-lo como operador para passar requisições para o banco. Vamos mudar uma configuração do banco, aumentar o limite de tempo para que ele corte o nossa conexão inexplicável.\nDBI::dbExecute(con, paste0(\u0026quot;SET GLOBAL connect_timeout = 600000;\u0026quot;) )  O que fazemos? Utilizamos a função dbExecute e passamos o objeto de conexão com o qual ela irá lidar. Após isso passamos uma string que será executada, apesar de eu ter me utilizado da função paste0, poderíamos ter passado a string diretamente. A função paste0 nos permite compor strings utilizando valores de outros objetos.\nVamos agora executar uma query para puxar os dados para um objeto do R.\nquery \u0026lt;- \u0026quot;SELECT * FROM T_FatoUtilizacao WHERE DtUtilizacao \u0026gt;= '2018-01-01' AND DtUtilizacao \u0026lt;= '2018-12-31';\u0026quot; dados \u0026lt;- DBI::dbGetQuery(con, query) %\u0026gt;% data.table::setDT()  Primeiro, crio um objeto com a consulta que será aplicada, depois utilizo da função dbGetQuery que executará a query armazenada no objeto query na conexão con. Após isso, redireciono a saída delas função com o operador %\u0026gt;% para a função setDT que irá transformar este objeto, in-place, num objeto data.table.\n","date":1576800000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576800000,"objectID":"d012c5e5238cd8de1779ab7f039a223e","permalink":"/tutoriais/r_basico/r_init/","publishdate":"2019-12-20T00:00:00Z","relpermalink":"/tutoriais/r_basico/r_init/","section":"tutoriais","summary":"R - Básico R em Container Agora que já se sabe como subir imagens de docker, vamos subir uma de R studio server com vários pacotes instalados para poder praticar.\nCASO NÃO QUEIRA PASSAR POR ISSO/ JÁ TEM UMA VERSÃO DO R INSTALADA E APENAS QUER VER UNS COMANDINHOS PULE PARA PROCESSA ETAMA (OLHE O TABLE OF CONTENTS DO LADO DIREITO)\nPrimeiro, vamos criar uma pasta de trabalho para o docker-compose.","tags":null,"title":"R basicão","type":"docs"},{"authors":null,"categories":null,"content":" Docker O Docker é uma tecnologia de contêiner. Um contêiner basicamente é um pacote em que há os códigos de uma aplicação, assim como toda a parte necessária (em questão de dependências de SO e bibliotecas da própria aplicação).\nO Docker é um software que permite a construção e execução destes contêineres. A construção é feita a partir de um \u0026lsquo;Dockerfile\u0026rsquo;, nada mais que uma receita de bolo. Este arquivo possui as diretrizes do que é necessário para sua aplicação rodar. Por meio dele é possível construir uma imagem, esta imagem quando executada cria o contêiner.\nA base do que iremos fazer depende do docker, então nessa etapa inicial ensinarei a instalar, dar alguns exemplos de chamadas e também como criar o Dockerfile.\nInstalação docker Para se usar alguma coisa é necessário primeiro tê-la, logo \u0026hellip; Irei basear a instalação em um Linux CentOS 7. A depender do sabor do linux utilizado faz com que algumas coisas nos sistema variem. Por exemplo, o comando de instalação de pacotes, o caminho de arquivos de configurações do sistema podem mudar. Assim como algumas \u0026ldquo;facilidades\u0026rdquo;, comandos podem existir num sabor e não em outro. Então caso procure algum tutorial de instalação, ou de solução de problemas, procure soluções de acordo com o sabor que estiver utilizando.\nDito isso, vamos começar a instalar o Docker para um sabor baseado em CentOS7.\nPara evitar problemas, vamos primeiro garantir que não haja nada de docker instalado na máquina.\nsudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine  Este comando tem o seguinte significado:\n sudo: Tem o significado de \u0026ldquo;faça\u0026rdquo; (do) como \u0026ldquo;super usuário\u0026rdquo; (su). O super usuário nada mais é que o administrador da máquina, tem plenos poderes sobre ela. Normalmente quando executado alguma coisa como super usuário não há qualquer pergunta (caso execute o comando para deletar um arquivo essencial para o sistema, não haverá qualquer pergunta, a execução será direta, caixão e vela preta). Outra opção ao sudo seria logar como SU e executando o comando posterior (em distribuições como Debian isso é necessário, pois não há comando sudo).\n yum: Este é um programa que gerencia os pacotes instalados do CentOS. Caso fosse uma distribuição baseada em Debian como Ubuntu seria aptou apt-get. Se fosse baseado em Arch seria pacman.\n remove: Este é um argumento para o programa yum. Este argumento informa que qualquer pacote descrito a frente deve ser removido.\n \\: Esta barra invertida é apenas uma quebra de linha para facilitar a visualização. Normalmente o comando existe em apenas uma única linha.\n  Vamos instalar o Docker via repositório. O repositório é um \u0026ldquo;espaço\u0026rdquo; em que seu OS \u0026ldquo;confia\u0026rdquo; para buscar pacotes e instalá-los na máquina. Normalmente o OS linux quando instalado já possui uma lista de repositórios confiáveis e oficiais em que pode contar, cada distribuição possui sua própria coleção de repositórios padrão. Aqui vamos adicionar um repositório nesta lista, o do docker-ce. Para isso, inicialmente será instalado alguns programas auxiliares ao yum, para podermos adicionar o novo repositório.\nsudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2  Agora adicionando o repositório:\nsudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo  Utilizando o programa auxiliar yum-config-manager adicionamos o repositório na lista do yum. O argumento --add-repo é um argumento de chamada para o programa, logo após, especificamos qual o valor deste argumento, o link para o repositório.\nAgora que temos o repositório onde o docker-ce existe podemos instalá-lo da seguinte forma (semelhante ao que já utilizamos antes):\nsudo yum install docker-ce docker-ce-cli containerd.io  O docker foi instalado, porém não iniciado, para isso:\nsudo systemctl start docker   sudo: Faça como super usuário\n systemctl: É o programa que organiza os processos do sistema\n start: É um argumento para o programa systemctl, dizendo para iniciar o programa de nome a frente.\n  Neste passo o Docker está iniciado. Mas há 2 poréns, o primeiro é que sempre que a máquina reiniciar o processo ficará parado, o segundo é que apenas o super usuário possui permissão de executar o docker.\nResolvendo o primeiro porém:\nsudo systemctl enable docker  Resolvendo o Segundo porém:\n Uma forma é sempre usar sudo para executar comandos docker\n A segunda é dar permissão ao seu usuário para executar comandos docker\nsudo usermod -aG docker $USER   Normalmente já existe um grupo chamado \u0026ldquo;docker\u0026rdquo; criado na hora da instalação. O que fazemos nesse comando é adicionar o nosso usuário $USER no grupo docker. Eu prefiro utilizar sempre o comando sudo para executar os comandos docker.\nVamos testar o docker:\nsudo docker run hello-world  Este comando executa uma imagem chamada hello-world (caso ela não exista no seu PC, o docker faz o download dela no repositório oficial do docker, o docker hub (não confundir com repositório de pacotes do sistema)).\nInstalação docker-compose O docker-compose ajuda na orquestração de uma imagem docker. Para executar uma imagem docker há vários parâmetros a serem setados para um comando só (como veremos adiante). Com o docker-compose é possível reescrever todos esses comandos em um único arquivo que pode ser versionado. Em um único arquivo, também é possível \u0026lsquo;levantar\u0026rsquo; várias imagens diferentes, com seus próprios argumentos e configuração de como essas imagens irão conversar.\nA instalação do docker-compose é diferente das demais. Ainda não há um pacote fechado para ele, o que fazemos nada mais é do que fazer o download de seus binários para um local do sistema e dar permissões a esses arquivos.\nsudo curl -L \u0026quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)\u0026quot; -o /usr/local/bin/docker-compose   curl: O curl é basicamente um navegador web para a linha de comando. Ele baixa o arquivo e o coloca no caminho especificado no output $(uname -s) e $(uname -m): São variáveis do sistema, o primeiro retorna \u0026ldquo;Linux\u0026rdquo; o segundo a arquitetura \u0026ldquo;x86_64\u0026rdquo;.  Agora é necessário dar permissão de execução para o arquivo:\nsudo chmod +x /usr/local/bin/docker-compose   chmod: Este comando altera permissões +x: Este é um argumento para o chmod o x significa \u0026lsquo;executável\u0026rsquo;.  Testando a instalação:\ndocker-compose --version  AEWW!!! Docker e Docker-compose instalados, agora vamos a exemplos:\nExemplos: Docker Vamos iniciar por exemplos simples, ver alguns comandos, subir algumas imagens simples e pequenas, subir alguma imagem de alguma aplicação visual (algo mais tátil), construir algum Dockerfile.\n\n","date":1564617600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564617600,"objectID":"16ad5c9d605b4b23e7a77f3149ce04b0","permalink":"/tutoriais/docker/docker_installation/","publishdate":"2019-08-01T00:00:00Z","relpermalink":"/tutoriais/docker/docker_installation/","section":"tutoriais","summary":"Docker O Docker é uma tecnologia de contêiner. Um contêiner basicamente é um pacote em que há os códigos de uma aplicação, assim como toda a parte necessária (em questão de dependências de SO e bibliotecas da própria aplicação).\nO Docker é um software que permite a construção e execução destes contêineres. A construção é feita a partir de um \u0026lsquo;Dockerfile\u0026rsquo;, nada mais que uma receita de bolo. Este arquivo possui as diretrizes do que é necessário para sua aplicação rodar.","tags":null,"title":"Docker Installation","type":"docs"},{"authors":null,"categories":null,"content":" R - Data.Table O data.table nada mais é do que uma reimaginação do data.frame do R. Ele é escrito primariamente em C. Possui uma série de otimizações focando em velocidade e economia de memória. Temos a liberdade de fazer operações inplace, evitando cópias desnecessárias que agridem a memória e demandam tempo.\nSeja dados um objeto data.table. Nosso acesso as manipulações ocorrem pela função [], temos a seguinte estrutura:\nTemos 3 slots:\n Primeiro, i: É a região dos filtros Segundo,j: É a região do que iremos fazer. Criar colunas? Dropar colunas? Agregação? Terceiro, by: É a região dos grupos, mas algumas vezes pode servir como filtro também, como num caso de JOIN.  Seria algo com dados[where, select|update|do, by]. Vamos começar com a parte do where, para isso vamos introduzir a função setkey.\nFiltro Já que iremos filtrar, vamos filtrar de forma eficiente. A função setkey tem como objetivo estabelecer um índice. A serventia é a mesma que num banco de dados, isto é feito para que, numa busca seja feito busca binária e não vector scan. Um ponto de atenção é que o objeto data.table é ordenado de acordo com o índice, dependendo do que está sendo feito isto pode ser um problema.\nVamos criar um dado sintético para trabalhar de tamanho razoável.\ndados \u0026lt;- data.table(categoria = sample.int(4, 10000000, replace = T), valor = rnorm(10000000, mean = 1000, sd = 20), sexo = sample.int(2, 10000000, replace = T) )  Temos um conjunto de dados de 10 milhões de linhas. Criamos dados fake, categoria, valor e sexo. Vamos criar um objeto que receba apenas os dados da categoria 1 e 2. Mas primeiro criaremos um índice.\nsetkey(dados,categoria)  Vamos comparar o filtro utilizando a chave e sem.\nrbenchmark::benchmark( \u0026quot;sem_key\u0026quot; = { filtro1 \u0026lt;- dados[categoria == 1 | categoria == 2] }, \u0026quot;com_key\u0026quot; ={ filtro2 \u0026lt;- dados[.(c(1,2))] }, order = \u0026quot;relative\u0026quot;, replications = 1, columns = c(\u0026quot;test\u0026quot;, \u0026quot;replications\u0026quot;, \u0026quot;relative\u0026quot;, \u0026quot;elapsed\u0026quot;) )  ## test replications relative elapsed ## 2 com_key 1 1.000 0.101 ## 1 sem_key 1 1.842 0.186  São iguais?\nall(filtro1 == filtro2)  ## [1] TRUE  A versão sem chave é mais lenta. Mas repare a velocidade com que filtramos uma tabela de 10 milhões de linhas e copiamos para um objeto novo em ambas as versões.\nAgora vamos explicar melhor.\nQuando não temos uma chave criada, filtramos o conjunto de dados utilizando vetores lógicos.\ndados[categoria == 1]  ## categoria valor sexo ## 1: 1 983.1805 2 ## 2: 1 1020.7571 2 ## 3: 1 1041.2756 1 ## 4: 1 984.5988 2 ## 5: 1 981.9217 2 ## --- ## 2501239: 1 1018.7187 2 ## 2501240: 1 1028.5804 1 ## 2501241: 1 1045.4142 1 ## 2501242: 1 993.8039 2 ## 2501243: 1 998.1015 2  Perceba que, eu faço referência ao nome da coluna de forma direta internamente. Podemos compor este vetor lógico de outras formas, utilizando outras colunas também, veja.\ndados[categoria == 1 \u0026amp; valor \u0026gt;= 1000 \u0026amp; sexo == 1]  ## categoria valor sexo ## 1: 1 1041.276 1 ## 2: 1 1012.897 1 ## 3: 1 1010.089 1 ## 4: 1 1018.702 1 ## 5: 1 1020.278 1 ## --- ## 624581: 1 1025.785 1 ## 624582: 1 1016.047 1 ## 624583: 1 1020.169 1 ## 624584: 1 1028.580 1 ## 624585: 1 1045.414 1  Porém, quando assim fazemos, não nos utilizamos da busca binária. Para usá-la precisamos criar as chaves e usar uma lista para passar os argumentos.\nsetkey(dados, categoria, sexo)  Não irei fazer busca num range de valor na busca binária, mas chegarei no mesmo resultado. Iremos fazer o mesmo filtro.\ndados[.(1,1)][valor \u0026gt;= 1000]  ## categoria valor sexo ## 1: 1 1041.276 1 ## 2: 1 1012.897 1 ## 3: 1 1010.089 1 ## 4: 1 1018.702 1 ## 5: 1 1020.278 1 ## --- ## 624581: 1 1025.785 1 ## 624582: 1 1016.047 1 ## 624583: 1 1020.169 1 ## 624584: 1 1028.580 1 ## 624585: 1 1045.414 1  Vejamos a diferença:\nrbenchmark::benchmark( \u0026quot;sem_key\u0026quot; = { filtro1 \u0026lt;- dados[categoria == 1 \u0026amp; valor \u0026gt;= 1000 \u0026amp; sexo == 1] }, \u0026quot;com_key\u0026quot; ={ filtro2 \u0026lt;- dados[.(1,1)][valor \u0026gt;= 1000] }, order = \u0026quot;relative\u0026quot;, replications = 1, columns = c(\u0026quot;test\u0026quot;, \u0026quot;replications\u0026quot;, \u0026quot;relative\u0026quot;, \u0026quot;elapsed\u0026quot;) )  ## test replications relative elapsed ## 2 com_key 1 1.00 0.028 ## 1 sem_key 1 5.75 0.161  São iguais?\nall(filtro1 == filtro2)  ## [1] TRUE  Observe que não estamos contando o tempo necessário para se criar as chaves. Porém quase sempre é melhor fazer a chave, pois podemos pensar numa chave que favoreça o maior número possível de filtros que será feito.\nAgregações / Mutate Agora vamos trabalhar na segunda parte do data.table, no \u0026ldquo;o que iremos fazer\u0026rdquo;. Aqui vamos fazer agregações. Temos 3 colunas, duas que indicam categorias e uma que indica um valor. Então, faremos alguns cálculos utilizando a coluna valor. Vamos crar um novo objeto data.table que tenha a média e desvio padrão deste valor.\ndados1 \u0026lt;- dados[, .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] dados1  ## media_valor desvio_padrao_valor ## 1: 1000.004 20.00367  O que vemos nesta expressão?\n dados[,: Não queremos fazer nenhum filtro, então deixamos seu respectivo espaço em branco. .(: Está função . é um alias para a função list. Estamos passando uma lista com as expressões que são feitas. media_valor = mean(valor): Aqui nomeio a nova coluna à esquerda da igualdade. No lado direito escrevo a expressão, aqui faço a média da coluna valor.  Vamos fazer o mesmo procedimento, só que para valores maiores que 1000.\ndados1 \u0026lt;- dados[valor \u0026gt; 1000, .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] dados1  ## media_valor desvio_padrao_valor ## 1: 1015.969 12.05818  Ao contrário da expressão anterior, adicionamos um filtro no espaço destinado a ele. Podemos reescrever isso de outra forma, já mostrada anteriormente, fazendo primeiro um data.table filtrado e continuando os cálculos. Isto pode ser feito com o pipe ou usando a função [, a segunda é mais recomendada pois não gera cópias.\n# com pipe library(magrittr) dados1A \u0026lt;- dados[valor \u0026gt; 1000] %\u0026gt;% .[, .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] #Com os [] dados1B \u0026lt;- dados[valor \u0026gt; 1000 ][ , .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] all(dados1A == dados1B)  ## [1] TRUE  Perceba que, criamos um novo objeto com o resultado. Porém, muitas vezes, se faz necessário adicionar essa informação como uma nova coluna, mesmo que ela seja redundante. Para isso, utilizaremos um outra função para escrever as expressões, a função :=. Veja.\ndados[, media_valor := mean(valor)] dados[, desvio_padrao_valor := sd(valor)] dados  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 1 1041.2756 1 1000.004 20.00367 ## 2: 1 989.1302 1 1000.004 20.00367 ## 3: 1 978.7430 1 1000.004 20.00367 ## 4: 1 998.9086 1 1000.004 20.00367 ## 5: 1 1012.8971 1 1000.004 20.00367 ## --- ## 9999996: 4 1018.1498 2 1000.004 20.00367 ## 9999997: 4 981.9318 2 1000.004 20.00367 ## 9999998: 4 1000.6837 2 1000.004 20.00367 ## 9999999: 4 987.9402 2 1000.004 20.00367 ## 10000000: 4 1038.9378 2 1000.004 20.00367  A função := também é utilizada para deleter colunas.\ndados[, c(\u0026quot;media_valor\u0026quot;, \u0026quot;desvio_padrao_valor\u0026quot;) := NULL]  Para utilizarmos uma mesma chamada para criar várias colunas novas, devemos utilizar a seguinte forma.\ndados[, `:=`(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] head(dados)  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 1 1041.2756 1 1000.004 20.00367 ## 2: 1 989.1302 1 1000.004 20.00367 ## 3: 1 978.7430 1 1000.004 20.00367 ## 4: 1 998.9086 1 1000.004 20.00367 ## 5: 1 1012.8971 1 1000.004 20.00367 ## 6: 1 1010.0885 1 1000.004 20.00367  A função := altera o data.table inplace, então tome cuidado quando for alterar colunas já existentes. A exemplo, vamos alterar uma coluna já existente utilizando de filtros.\ndados[valor \u0026gt; 1000, `:=`(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ) ] head(dados)  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 1 1041.2756 1 1015.969 12.05818 ## 2: 1 989.1302 1 1000.004 20.00367 ## 3: 1 978.7430 1 1000.004 20.00367 ## 4: 1 998.9086 1 1000.004 20.00367 ## 5: 1 1012.8971 1 1015.969 12.05818 ## 6: 1 1010.0885 1 1015.969 12.05818  Observou que alguns dos dados da coluna alterada aparentam serem os mesmos? A coluna só foi alterada onde a condição do filtro é satisfeita, que é valor \u0026gt; 1000. Veja:\nsetorder(dados, valor) dados[c(1:5, (nrow(dados)-5):nrow(dados))]  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 2 900.4804 2 1000.004 20.00367 ## 2: 3 902.8411 1 1000.004 20.00367 ## 3: 1 903.1211 1 1000.004 20.00367 ## 4: 2 903.4796 1 1000.004 20.00367 ## 5: 4 903.6676 1 1000.004 20.00367 ## 6: 4 1100.1116 1 1015.969 12.05818 ## 7: 4 1100.5020 1 1015.969 12.05818 ## 8: 2 1101.6412 1 1015.969 12.05818 ## 9: 4 1102.5581 1 1015.969 12.05818 ## 10: 3 1103.1713 2 1015.969 12.05818 ## 11: 3 1105.0339 1 1015.969 12.05818  Vamos criar agora uma label para a variável sexo. Veremos o que acontecerá.\nsetkey(dados, sexo) dados[.(sexo = 1), SexoBeneficiario := \u0026quot;Masculino\u0026quot;] dados[c(1,500,10000000)]  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 3 902.8411 1 1000.004 20.00367 ## 2: 3 926.0478 1 1000.004 20.00367 ## 3: 3 1103.1713 2 1015.969 12.05818 ## SexoBeneficiario ## 1: Masculino ## 2: Masculino ## 3: \u0026lt;NA\u0026gt;  Eu solicitei a impressão das linhas 1, 500 e 10000000. Veja a variável que criamos, observe que para onde as condições do filtro não foram satisfeitas não foi aplicado nenhum valor para a nova variável SexoBeneficiario.\ndados[.(sexo = 2), SexoBeneficiario := \u0026quot;Feminino\u0026quot;] dados[c(1,500,10000000)]  ## categoria valor sexo SexoBeneficiario ## 1: 3 902.8411 1 Masculino ## 2: 3 926.0478 1 Masculino ## 3: 3 1103.1713 2 Feminino  Pronto, podemos fazer isso de outra forma, veremos qual será mais rápido, para isso iremos deletar esta coluna.\ndados[, SexoBeneficiario := NULL]  options(datatable.verbose=F, datatable.auto.index = F) rbenchmark::benchmark( \u0026quot;sem_key_ifelse\u0026quot; = { dados[, SexoBeneficiario1 := ifelse(sexo == 1, \u0026quot;Masculino\u0026quot;, \u0026quot;Feminino\u0026quot;)] }, \u0026quot;sem_key_data.table\u0026quot;= { dados[sexo == 1, SexoBeneficiario2 := \u0026quot;Masculino\u0026quot;] dados[sexo == 2, SexoBeneficiario2 := \u0026quot;Feminino\u0026quot;] }, \u0026quot;com_key\u0026quot; ={ dados[.(sexo = 1), SexoBeneficiario3 := \u0026quot;Masculino\u0026quot;] dados[.(sexo = 2), SexoBeneficiario3 := \u0026quot;Feminino\u0026quot;] }, order = \u0026quot;relative\u0026quot;, replications = 1, columns = c(\u0026quot;test\u0026quot;, \u0026quot;replications\u0026quot;, \u0026quot;relative\u0026quot;, \u0026quot;elapsed\u0026quot;) )  ## test replications relative elapsed ## 2 sem_key_data.table 1 1.000 0.209 ## 3 com_key 1 1.033 0.216 ## 1 sem_key_ifelse 1 8.321 1.739  São iguais?\nall(dados$SexoBeneficiario2 == dados$SexoBeneficiario3)  ## [1] TRUE  Agora vamos ativar a função de auto index do data.table. O que ela faz? Basicamente observar quais filtros irá fazer e cria um índice por trás dos panos. Porém ele não reordena o objeto em si, é criado uma coluna com esse índice nos atributos do objeto. Ainda é mais lento do que criar uma Chave, mas já ajuda bastante, veja:\noptions(datatable.verbose=F, datatable.auto.index = T) rbenchmark::benchmark( \u0026quot;sem_key_ifelse\u0026quot; = { dados[, SexoBeneficiario1 := ifelse(sexo == 1L, \u0026quot;Masculino\u0026quot;, \u0026quot;Feminino\u0026quot;)] }, \u0026quot;sem_key_data.table\u0026quot;= { dados[sexo == 1L, SexoBeneficiario2 := \u0026quot;Masculino\u0026quot;] dados[sexo == 2L, SexoBeneficiario2 := \u0026quot;Feminino\u0026quot;] }, \u0026quot;com_key\u0026quot; ={ dados[.(sexo = 1L), SexoBeneficiario3 := \u0026quot;Masculino\u0026quot;] dados[.(sexo = 2L), SexoBeneficiario3 := \u0026quot;Feminino\u0026quot;] }, order = \u0026quot;relative\u0026quot;, replications = 1, columns = c(\u0026quot;test\u0026quot;, \u0026quot;replications\u0026quot;, \u0026quot;relative\u0026quot;, \u0026quot;elapsed\u0026quot;) )  ## test replications relative elapsed ## 3 com_key 1 1.000 0.165 ## 2 sem_key_data.table 1 1.073 0.177 ## 1 sem_key_ifelse 1 9.945 1.641  O index apenas funciona para == e %in%. Uma coisa que devemos ter cuidado é sempre utilizar os tipos certos para se fazer comparação e para atribuir valores, conversões saem caras em questão de performance, assim sempre que possível devemos atribuir as coisas de forma correta, como em sexo == 1L aqui eu especifico com o L que o número à esquerda é um inteiro.\nAgrupamento Nós já fizemos agregações na sessão anterior. Iremos fazer a exata mesma coisa, porém agora podemos agrupar os cálculos em grupos (basicamente o GROUP BY de qualquer SQL).\nVamos utilizar o mesmo mesmo exemplo anterior, só que agora agrupando por categoria\nLimpe seus dados (caso ainda o tenha) e libere a memória.\nrm(dados) gc(reset = T)  ## used (Mb) gc trigger (Mb) max used (Mb) ## Ncells 599594 32.1 1069260 57.2 599594 32.1 ## Vcells 3693424 28.2 90661241 691.7 3693424 28.2  Vamos declarar o dados novamente\ndados \u0026lt;- data.table(categoria = sample.int(4, 10000000, replace = T), valor = rnorm(10000000, mean = 1000, sd = 20), sexo = sample.int(2, 10000000, replace = T) )  Iremos calcular a média e desvio padrão para cada nível da variável categoria\ndados[, .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ), by = .(categoria) ]  ## categoria media_valor desvio_padrao_valor ## 1: 4 999.9855 19.99456 ## 2: 2 999.9867 20.00855 ## 3: 1 1000.0115 20.00871 ## 4: 3 999.9952 19.99853  Esta foi uma agregação, um resumo, vamos criar as mesmas duas métricas para cada categoria, um mutate.\ndados[, `:=`(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ), by = .(categoria) ] head(dados)  ## categoria valor sexo media_valor desvio_padrao_valor ## 1: 4 1006.5045 2 999.9855 19.99456 ## 2: 4 999.9418 2 999.9855 19.99456 ## 3: 2 984.4775 2 999.9867 20.00855 ## 4: 1 1030.6272 2 1000.0115 20.00871 ## 5: 1 995.2280 1 1000.0115 20.00871 ## 6: 2 1000.1660 1 999.9867 20.00855  Também podemos fazer agrupamentos por mais de uma variável. Aqui será feito com categoria e sexo.\ndados[, .(media_valor = mean(valor), desvio_padrao_valor = sd(valor) ), by = .(categoria, sexo) ]  ## categoria sexo media_valor desvio_padrao_valor ## 1: 4 2 999.9882 19.98116 ## 2: 2 2 999.9859 20.01013 ## 3: 1 2 1000.0132 20.00674 ## 4: 1 1 1000.0099 20.01069 ## 5: 2 1 999.9875 20.00697 ## 6: 4 1 999.9828 20.00795 ## 7: 3 1 999.9711 19.98177 ## 8: 3 2 1000.0192 20.01526  JOINss O data.tabletem seu modo de realizar JOINS e JOINS inplace. É eficiente, mas pode confundir um pouco.\nPrimeiro iremos criar as tabelas, A será um índice, contendo 1 e 2. B será uma índice com uma label.\nA \u0026lt;- data.table(id_A = sample.int(2, size = 10000,replace = T)) A[id_A == 1, label_A := \u0026quot;A\u0026quot;] A[id_A == 2, label_A := \u0026quot;B\u0026quot;] B \u0026lt;- data.table(id_B = 1:2, label_B = c(\u0026quot;Masculino\u0026quot;, \u0026quot;Feminino\u0026quot;) ) head(A)  ## id_A label_A ## 1: 2 B ## 2: 1 A ## 3: 2 B ## 4: 1 A ## 5: 2 B ## 6: 1 A  B  ## id_B label_B ## 1: 1 Masculino ## 2: 2 Feminino  Os JOINS podem ser definidos pela seguinte forma\nLEFT JOIN ### LEFT JOIN EM A com B B[A, on =c(\u0026quot;id_B\u0026quot; = \u0026quot;id_A\u0026quot;)] # LEFT JOIN COM COPIA  ## id_B label_B label_A ## 1: 2 Feminino B ## 2: 1 Masculino A ## 3: 2 Feminino B ## 4: 1 Masculino A ## 5: 2 Feminino B ## --- ## 9996: 1 Masculino A ## 9997: 1 Masculino A ## 9998: 1 Masculino A ## 9999: 1 Masculino A ## 10000: 2 Feminino B  ### LEFT JOIN EM A com B A[B, label_B := label_B, on =c(\u0026quot;id_A\u0026quot; = \u0026quot;id_B\u0026quot;)] # LEFT JOIN SEM COPIA A  ## id_A label_A label_B ## 1: 2 B Feminino ## 2: 1 A Masculino ## 3: 2 B Feminino ## 4: 1 A Masculino ## 5: 2 B Feminino ## --- ## 9996: 1 A Masculino ## 9997: 1 A Masculino ## 9998: 1 A Masculino ## 9999: 1 A Masculino ## 10000: 2 B Feminino  ### LEFT JOIN EM B com A B[A, label_A := label_A, on =c(\u0026quot;id_B\u0026quot; = \u0026quot;id_A\u0026quot;)] # LEFT JOIN SEM COPIA B  ## id_B label_B label_A ## 1: 1 Masculino A ## 2: 2 Feminino B  Para colocar várias colunas da tabela à direita para a direita num LEFT JOIN SEM COPIA é necessário um pouco mais de trabalho. Veja, é só um pouco mais de trabalho.\nPrimeiro, crio esta função auxiliar, ela irá construir o código responsável pelo lhs := rhs de várias colunas e retorno como uma expressão do R. Após isso eu avalio essa expressão dentro do data.table\npull_right \u0026lt;- function(columns,exceptions){ columns \u0026lt;- columns[!columns %in% exceptions] string \u0026lt;- paste( \u0026quot;`:=`(\u0026quot;,paste(columns, columns, sep = \u0026quot;=\u0026quot;, collapse = \u0026quot;,\u0026quot;), \u0026quot;)\u0026quot;) return(parse(text =string)) } pull_right(columns = c(\u0026quot;label_A\u0026quot;, \u0026quot;label_B\u0026quot;), exceptions = c(\u0026quot;id\u0026quot;))  ## expression(`:=`(label_A = label_A, label_B = label_B))  Vejamos o exemplo anterior, utilizando desta função:\n# DECLARANDO AS MATRIZES NOVAMENTE A \u0026lt;- data.table(id_A = sample.int(2, size = 10000,replace = T)) A[id_A == 1, label_A := \u0026quot;A\u0026quot;] A[id_A == 2, label_A := \u0026quot;B\u0026quot;] B \u0026lt;- data.table(id_B = 1:2, label_B = c(\u0026quot;Masculino\u0026quot;, \u0026quot;Feminino\u0026quot;) ) # # # # LEFT JOIN IN PLACE A[B, eval(pull_right(columns = \u0026quot;label_B\u0026quot;, exceptions = \u0026quot;id_B\u0026quot;) ), on = .(id_A == id_B) ] A  ## id_A label_A label_B ## 1: 2 B Feminino ## 2: 1 A Masculino ## 3: 2 B Feminino ## 4: 2 B Feminino ## 5: 1 A Masculino ## --- ## 9996: 1 A Masculino ## 9997: 1 A Masculino ## 9998: 2 B Feminino ## 9999: 1 A Masculino ## 10000: 2 B Feminino  RIGHT JOIN Reimagine um RIGHT JOIN como um LEFT JOIN e faz como no passo anterior\nINNER JOIN Vamos criar datasets de exemplo.\nA \u0026lt;- data.table(id_A = 1:10, label_A = \u0026quot;alguma coisa\u0026quot; ) B \u0026lt;- data.table(id_B = 1:4, label_B = \u0026quot;MATCH\u0026quot;)  Para o INNER JOIN FAZEMOS\nA[B, on = c(\u0026quot;id_A\u0026quot; = \u0026quot;id_B\u0026quot;), nomatch = 0]  ## id_A label_A label_B ## 1: 1 alguma coisa MATCH ## 2: 2 alguma coisa MATCH ## 3: 3 alguma coisa MATCH ## 4: 4 alguma coisa MATCH  NOT JOIN Vamos criar datasets de exemplo.\nA \u0026lt;- data.table(id_A = 1:10, label_A = \u0026quot;alguma coisa\u0026quot; ) B \u0026lt;- data.table(id_B = 1:4, label_B = \u0026quot;MATCH\u0026quot;)  Para o NOT JOIN temos\nA[!B, on = c(\u0026quot;id_A\u0026quot; = \u0026quot;id_B\u0026quot;)]  ## id_A label_A ## 1: 5 alguma coisa ## 2: 6 alguma coisa ## 3: 7 alguma coisa ## 4: 8 alguma coisa ## 5: 9 alguma coisa ## 6: 10 alguma coisa  NON EQUI JOIN Este JOIN serve para quando queremos fazer um match baseado em desigualdade. Vamos a criação do dataset e ao exemplo.\nA \u0026lt;- data.table(id_A = 1:20, label_A = \u0026quot;alguma coisa\u0026quot; ) B \u0026lt;- data.table(id_B = 15:25, label_B = \u0026quot;MATCH\u0026quot;)  Vejamos A e B\nA  ## id_A label_A ## 1: 1 alguma coisa ## 2: 2 alguma coisa ## 3: 3 alguma coisa ## 4: 4 alguma coisa ## 5: 5 alguma coisa ## 6: 6 alguma coisa ## 7: 7 alguma coisa ## 8: 8 alguma coisa ## 9: 9 alguma coisa ## 10: 10 alguma coisa ## 11: 11 alguma coisa ## 12: 12 alguma coisa ## 13: 13 alguma coisa ## 14: 14 alguma coisa ## 15: 15 alguma coisa ## 16: 16 alguma coisa ## 17: 17 alguma coisa ## 18: 18 alguma coisa ## 19: 19 alguma coisa ## 20: 20 alguma coisa  B  ## id_B label_B ## 1: 15 MATCH ## 2: 16 MATCH ## 3: 17 MATCH ## 4: 18 MATCH ## 5: 19 MATCH ## 6: 20 MATCH ## 7: 21 MATCH ## 8: 22 MATCH ## 9: 23 MATCH ## 10: 24 MATCH ## 11: 25 MATCH  Vamos fazer o match onde id_B é menor que id_A\nB[A, on = .(id_B \u0026lt; id_A)]  ## id_B label_B label_A ## 1: 1 \u0026lt;NA\u0026gt; alguma coisa ## 2: 2 \u0026lt;NA\u0026gt; alguma coisa ## 3: 3 \u0026lt;NA\u0026gt; alguma coisa ## 4: 4 \u0026lt;NA\u0026gt; alguma coisa ## 5: 5 \u0026lt;NA\u0026gt; alguma coisa ## 6: 6 \u0026lt;NA\u0026gt; alguma coisa ## 7: 7 \u0026lt;NA\u0026gt; alguma coisa ## 8: 8 \u0026lt;NA\u0026gt; alguma coisa ## 9: 9 \u0026lt;NA\u0026gt; alguma coisa ## 10: 10 \u0026lt;NA\u0026gt; alguma coisa ## 11: 11 \u0026lt;NA\u0026gt; alguma coisa ## 12: 12 \u0026lt;NA\u0026gt; alguma coisa ## 13: 13 \u0026lt;NA\u0026gt; alguma coisa ## 14: 14 \u0026lt;NA\u0026gt; alguma coisa ## 15: 15 \u0026lt;NA\u0026gt; alguma coisa ## 16: 16 MATCH alguma coisa ## 17: 17 MATCH alguma coisa ## 18: 17 MATCH alguma coisa ## 19: 18 MATCH alguma coisa ## 20: 18 MATCH alguma coisa ## 21: 18 MATCH alguma coisa ## 22: 19 MATCH alguma coisa ## 23: 19 MATCH alguma coisa ## 24: 19 MATCH alguma coisa ## 25: 19 MATCH alguma coisa ## 26: 20 MATCH alguma coisa ## 27: 20 MATCH alguma coisa ## 28: 20 MATCH alguma coisa ## 29: 20 MATCH alguma coisa ## 30: 20 MATCH alguma coisa ## id_B label_B label_A  Esse é um JOIN bem confuso e é muito fácil fazer coisa errada. São raros os casos em que ele é necessário. Normalmente preenchimento de alguma coisa relacionada a uma linha temporal. Eu sugiro que tente usar ao máximo outras formas de fazer o que queira antes de tentar o NON EQUI JOINS.\n","date":1576800000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576800000,"objectID":"e083a4adc13d2e7906a0c38c9776f473","permalink":"/tutoriais/r_basico/r_datatable/","publishdate":"2019-12-20T00:00:00Z","relpermalink":"/tutoriais/r_basico/r_datatable/","section":"tutoriais","summary":"R - Data.Table O data.table nada mais é do que uma reimaginação do data.frame do R. Ele é escrito primariamente em C. Possui uma série de otimizações focando em velocidade e economia de memória. Temos a liberdade de fazer operações inplace, evitando cópias desnecessárias que agridem a memória e demandam tempo.\nSeja dados um objeto data.table. Nosso acesso as manipulações ocorrem pela função [], temos a seguinte estrutura:\nTemos 3 slots:","tags":null,"title":"R Data Table","type":"docs"},{"authors":null,"categories":null,"content":" Comandos: run O comando run, quando não utilizado com outra ferramente de orquestração, como docker-compose, kubernets, ou outro, será o comando mais utilizado. Ele roda um container por meio de uma imagem, normalmente o container executa um comando e morre. A imagem hello-world basicamente executa um print de texto no console e depois morre (na verdade finaliza com sucesso). Se subirmos um script batch, será executado tudo que deve ser feito e depois o container morre. Se subirmos um serviço contínuo o comportamento ainda é o mesmo, porém a \u0026ldquo;sensação\u0026rdquo; é outra, por exemplo, subimos um serviço de banco de dados, o comando que a imagem terá é executar o banco, a imagem continuará ativa durante toda a \u0026ldquo;execução do comando\u0026rdquo;, ou seja, a imagem só irá morrer caso o banco de dados morra por algum motivo.\nPrimeiro, há duas formas de executar uma imagem, no Foreground (seu console vai ficar preso no que for executado) e no Background (ou detached) o container será executada no plano de fundo.\nVamos subir um bash de uma imagem que seja um OS ubuntu em foreground:\nsudo docker run -it ubuntu bash   run: Comando que executa uma imagem -it: Argumentos para o comando run, i significa interativo, t ativa um tipo de buffer para entradas de texto ubuntu: O nome da imagem que será executado bash: O programa q será executado dentro da imagem, neste caso iniciaremos o console.  Note que, agora você está num ambiente ubuntu, dentro do container Aqui você pode fazer qualquer coisa, inclusive deletar seu OS (pois quando restartar o container ele virá no mesmo formato de antes, que é o que foi colocado na imagem). Faça alguns testes aqui a seu prazer.\nPara sair de dentro da imagem execute exit.\nVamos agora subir um container mais \u0026ldquo;visual\u0026rdquo;. Muitos estão falando sobre o Metabase, um visualizador gratuito. Então vamos subir uma aplicação em Foreground de Metabase para que possamos acessá-la.\nsudo docker run -p 8787:3000 metabase/metabase   -p: Aqui temos um argumento novo, a porta. O app fica exposto numa porta, nesse caso na porta 3000. Porém essa porta é do contêiner e nós acessamos a máquina (host), então é necessário que seja construído um caminho para a porta do container. Então, quando se acessa http://127.0.0.1:8787/setup você está acessando na verdade o contêiner na porta 3000. Caso você esteja em alguma instância o endereço seria http://ip-da-instancia:8787/setup. (porta do host à esquerda e do contêiner à direita)\n metabase/metabase: O nome da imagem, caso não tenha a imagem no PC o docker irá procurar em seu repositório\n  Observe seu terminal, veja que ele está preso à aplicação, caso seu terminal morra a aplicação também irá sofrer o mesmo destino. Vamos subir a aplicação no modo detached.\nMas primeiro mate sua execução atual CTRL + C.\nAgora sim, vamos subir no modo detached.\nsudo docker run -d -p 8787:3000 metabase/metabase  Observe agora que o terminal está livre e a aplicação continua rodando. E agora que a imagem já está no PC, observe a velocidade que a aplicação entra em operação.\nPodemos ainda fazer:\nsudo docker run --rm -d -p 8787:3000 metabase/metabase   --rm: Este argumento diz que, quando o container morrer ou ser parado, ele deve ser removido.  O comando run tem muitas outras opções, como por exemplo dar acesso a pastas do host para o contêiner, declarar variáveis de ambiente, etc. Mas vamos deixar isso para depois, quando estivermos falando de docker-compose.\n\nComandos: container O comando container nos permite verificar informações referentes aos containers. O container é a aplicação/imagem que foi executada ou está em execução.\nPrimeiramente vamos verificar os containers ativos, aquelas imagens que estão em execução.\nsudo docker container ls   ls: O argumento ls significa listar:  Caso você tenha executado o exemplo detached do metabase da sessão anterior terá uma linha preenchida com as informações deste contêiner. Verá que ele está ativo, em qual porta, qual o comando executado e a quanto tempo.\nAo fazer:\nsudo docker container ls -a   -a: Este argumento representa \u0026ldquo;all\u0026rdquo;  É possível ver todos os contêineres que já foram executados.\nVamos então matar esse container ativo que não mais necessitamos. Ao executar sudo docker container ls podemos ver os ativos, observe que, cada contêiner possui um CONTAINER ID, é por ele iremos matar o processo, basta fazer:\nsudo docker container kill CONTAINER_ID  No meu caso o comando foi sudo docker container kill 816e65266526, observe com sudo docker container ls que o contêiner não está mais de pé.\nHá outros argumentos que podem ser utilizados junto com container, entre eles estão exec, restart, pause, inspec, start, stop, unpause, logs, etc. Normalmente eles estão ligados à manutenção de containers, sugiro que sejam estudados caso a necessidade (preciso visualizar as entranhas do meu container para observar algo, etc).\n\nComandos: image Este comando tem o objetivo de gerir as imagens que existem. Inicialmente iremos utilizar bastante esse comando para poder baixar e subir imagens para o nosso repositório.\nVamos listar todas as imagens que estão salvas.\nsudo image ls -a  Observe os tamanhos de cada imagem, todas essas imagens estão salvas no HD. A medida que são utilizadas o espaço do HD vai diminuindo. Vamos deletar a imagem do ubuntu\nsudo docker rmi ubuntu  Caso tenha alguma imagem dependente da que iremos remover é necessário forçar a remoção\nsudo docker rmi -f ubuntu  Vamos baixá-la novamente.\nsudo docker image pull ubuntu  Falarei de como subir imagens somente após a construção da nossa primeira imagem.\n\nComandos: prune Este é um comando muito útil. Nós temos um histórico no docker, como por exemplo todos os contêineres já executados sudo docker container ls -a, e imagens que não mais utilizamos. O prune tem como objetivo limpar todos esse lixo. Ele pode ser feito em etapas ou em todo o docker. Vamos por etapas.\nContainer:\nVeja quantos container que estão parados:\nsudo docker container ls -a  Podemos remover todos os containers parados com:\nsudo docker container prune  Podemos ainda filtrar, aqui removemos todos os container parados que possuem mais de 24 horas.\nsudo docker container prune --filter=\u0026quot;until24h\u0026quot;  Images:\nPodemos remover imagens que são \u0026ldquo;zumbis\u0026rdquo;. Essas imagens são aquelas estão referenciadas por nenhum container ou imagem.\nsudo docker image prune  Podemos remover todas as imagens que não estejam associadas a um container:\nsudo docker image prune -a  E assim como no exemplo dos container podemos utilizar filtros\nsudo docker image prune --filter=\u0026quot;until24h\u0026quot;  Tudo:\nPodemos fazer um prune de tudo ao mesmo tempo incluindo Networks (Não abordei Networks nesse documento, mas acho pertinente fazer uma pesquisa em separa quando ir surgindo a necessidade de ligar com essas configurações, mas num resumo bem breve, podemos criar Networks internas para os containers de modo que eles apenas se comuniquem num espaço fechado)\nsudo docker system prune  Execute esse comando e depois observe quantos containers você possui e quantas imagens salvas.\n\nComandos: build VAMOS CONSTRUIR!!!!!\nVamos construir nosso primeiro Dockerfile. O Dockerfile é uma receita de bolo, dizendo como será a imagem. Essa receita de bolo consiste em empilhar comandos do próprio Linux num arquivo interpretável. Existe um procedimento de como deixar as imagens menores e mais eficientes, mas isso não é importante no momento, apenas construa a seu prazer para testar as possibilidades.\nO Dockerfile se baseia nos seguintes comandos:\n FROM: A imagem inicial que sua imagem irá se basear (normalmente algo pequeno, para um ambiente de DEV costuma ser um OS e para produção um OS mais capado possível) RUN: Aqui dizemos os comandos que serão executados antes da imagem estar pronta (instalar pacotes por exemplo) MAINTAINER: O autor do arquivo COPY: Copia algum arquivo para dentro da imagem (assim quando a imagem for iniciada ela já possui o arquivo) USER: Define qual será o usuário padrão para a imagem ENTRYPOINT: Define qual a aplicação do container Normalmente é um arquivo em shell dentro da imagem com tudo para ser executado. É executado quanto a imagem é executada (na criação de um container). CMD: Semelhante ao ENTRYPOINT, pode executar um comando na execução da imagem, ou passar argumentos para o ENTRYPOINT. Porém o CMD pode ser \u0026ldquo;ofuscado\u0026rdquo; por algum outro comando na hora de executar a imagem, exemplo sudo docker run --rm -it ubuntu /bin/bash, aqui estamos executando a imagem ubuntu com o CMD /bin/bash que substitui qualquer outro CMD dentro da imagem.  Vamos preparar o terreno. Primeiro precisamos de uma área de trabalho para essa imagem que vamos criar. Então vamos criar um caminho de pastas para nosso Dockerfile ficar isolado e entrar nessas pasta.\nmkdir teste_docker cd teste_docker   mkdir: Significa \u0026ldquo;make a directory\u0026rdquo;, estamos criando uma pasta chamada teste_docker cd: Significa \u0026ldquo;change directory\u0026rdquo;, vamos entrar na pasta teste_docker.  Estamos dentro da pasta de trabalho, agora iremos criar um arquivo de texto e começar a construir nossa imagem. Vamos utilizar o programa nano, caso não tenha instale:\nPara CentOS\nsudo yum install nano  Para ubuntu/debian\nsudo apt-get install nano  Vamos criar um executável para passar para dentro da imagem.Observe que, após executar esse comando agora temos uma página em branco para ser preenchida. Para salvar o arquivo após algo escrito aperte CTRL+ O, para sair do editor nano e retornar ao terminal CTRL+X. Vamos preencher o documento.\nnano text_print.sh  Coloque o seguinte texto:\n#!/usr/bin/env bash echo \u0026quot;ESTAMOS IMPRIMIIINDOO\u0026quot;  Vamos criar um arquivo chamado Dockerfile:\nnano Dockerfile  Vamos colocar o seguinte texto:\nFROM ubuntu # da imagem ubuntu MAINTAINER eu_mesmo # autor RUN apt-get update \\ \u0026amp;\u0026amp; apt-get install -y mariadb-client \\ libmariadbclient-dev \\ libmariadb-client-lgpl-dev \\ \u0026amp;\u0026amp; apt-get clean \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/* \\ \u0026amp;\u0026amp; rm -rf /tmp/* COPY text_print.sh /text_print.sh RUN chmod 755 /text_print.sh ENTRYPOINT /text_print.sh  A seguir CTRL+O para salvar e CTRL+X para sair.\nAcima temos:\n FROM: imagem ubuntu MAINTAINER: autor RUN: Executo uma série de comandos, primeiro dou update nos repositórios do apt-get (instalador de pacotes do ubuntu). Depois instalo 3 pacotes, cliente e bibliotecas do MariaDB. Após isso eu limpo o cache de instalação e deleto qualquer arquivo intermediário que possa ter ficado das instalações. COPY: Copio o arquivo que criamos anteriormente e coloco na raiz RUN: Dou permissão para esse arquivo ser executado -ENTRYPOINT: Aponto o que será executado quando a subirmos o contêiner.  Agora que temos a receita vamos construir a imagem \u0026ldquo;buildar\u0026rdquo;. A pasta deve conter apenas dois arquivos, verifique:\nls  Deve retornar isso:\nDockerfile text_print.sh  Então vamos buildar a imagem:\nsudo docker build -t imagem_teste .   build: é o comando para construir a imagem -t: é o argumento dizendo que vamos nomear a nossa imagem imagem_teste: O nome da nossa imagem .: O comando build precisa que você referencie a pasta onde está o Dockerfile e os arquivos necessários para a construção. O . referencia a pasta que você está no presente momento com o console.  Aguarde a imagem terminar de buildar e verifique:\nsudo docker image ls  Caso você tenha uma conta no docker hub (repositório oficial) ou tenha algum repositório de imagens configurado você pode fazer o seguinte para subir a imagem para tal.\nsudo docker tag imagem_teste seu_nome_usuario_repo/imagem_teste sudo docker push seu_nome_usuario_repo/imagem_teste  Primeiro renomeia a imagem, colocando seu usuário como prefixo. Depois usar o push, para o upload da imagem, irá pedir um login e senha do repositório e irá iniciar o upload.\nVamos testar a imagem!!\nsudo docker run imagem_teste  Imprimiu o que queríamos?\nVamos sair desta pasta que criamos e voltar para onde estávamos\ncd ..   ..: Este símbolo significa subir uma pasta  \n","date":1564617600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564617600,"objectID":"6b3cd1ea75be5147ab81b6ed225fb3da","permalink":"/tutoriais/docker/docker_commandos/","publishdate":"2019-08-01T00:00:00Z","relpermalink":"/tutoriais/docker/docker_commandos/","section":"tutoriais","summary":"Comandos: run O comando run, quando não utilizado com outra ferramente de orquestração, como docker-compose, kubernets, ou outro, será o comando mais utilizado. Ele roda um container por meio de uma imagem, normalmente o container executa um comando e morre. A imagem hello-world basicamente executa um print de texto no console e depois morre (na verdade finaliza com sucesso). Se subirmos um script batch, será executado tudo que deve ser feito e depois o container morre.","tags":null,"title":"Docker Commands","type":"docs"},{"authors":null,"categories":null,"content":" Docker-compose O docker-compose tem como objetivo melhor organizar os container Ele nada mais é do que uma instrução de como subir contêineres e Networks, uma versão em arquivo do docker run. Vamos fazer exemplos e compará-los.\nExemplo 1: Subir um container numa porta específica Vamos subir um container numa porta específica e dar nome a ele, assim podemos identificar pelo nome do container qual aplicação está rodando com o comando run.\nsudo docker run -d -p 8787:8787 --name=r_server_1 zegkreist/r-dl-cpu  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = rstudio e senha = rstudio.\nVamos derrubar o serviço utilizando o nome do contêiner.\nsudo docker container kill r_server_1  Agora vamos criar um arquivo docker-compose e utilizar seu sistema para levantar a aplicação.\nPrimeiro, vamos criar uma pasta de trabalho:\nmkdir docker_compose_rstudio_server  Vamos entrar na pasta:\ncd docker_compose_rstudio_server  Agora vamos criar um arquivo docker-compose.yml e preencher seu conteúdo.\nnano docker-compose.yml  Estamos dentro do editor de texto nano, coloque o seguinte conteúdo:\nversion: '2' services: r-dl-cpu_teste: image: zegkreist/r-dl-cpu container_name: r_server_1 restart: always ports: - \u0026quot;8787:8787\u0026quot;   version: A versão do docker-compose que iremos utilizar, cada uma possui seus features. services: Os serviços que iremos levantar, pode ser mais de 1, neste caso será somente um o r-dl-cpu-teste r-dl-cpu_teste: Este é o serviço (que nomeamos nós mesmos) que será levantado, tudo que está indentado com ele são suas definições. image: Estamos informando qual a imagem que será utilizado pelo serviço container_name: O nome que o container receberá restart: A política de restart do serviço, neste caso always significa que, caso o serviço morra ele será levantado novamente de imediato ports: Aqui estamos informando o mapping das portas, pode ser mais de um map por vez.  Pressione CTRL+O para salvar e CTRL+X para sair. Agora vamos subir o serviço\ndocker-compose up -d  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = rstudio e senha = rstudio.\nVamos matar o serviço, para isso basta apenas:\ndocker-compose down  Exemplo 2: Subir uma imagem passando variáveis de ambiente É possível passar variáveis de ambiente para uma imagem utilizar na execução de um container. Isso se faz importante para que logins e senhas não fique hardcoded em códigos dentro do container. Podemos então passar essas variáveis e consumi-las em nosso códigos.\nEsta imagem em específico permite que passemos variáveis de usuário, Id do usuário e senha para que automaticamente se crie um usuário com senha para acessar o R server. Caso elas não sejam passadas é criado o usuário padrão rstudio:rstudio.\nVamos subir esta imagem utilizando o comando run, veja que, o comando já fica desagradável aos olhos (e não pode ser versionado).\nsudo docker run -d -p 8787:8787 --name=r_server_1 -e USER='teste' \\ -e USERID='1000' \\ -e PASSWORD='facil123' zegkreist/r-dl-cpu  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = teste e senha = facil123.\nVamos interromper o serviço.\nsudo docker container kill r_server_1  Agora, iremos editar novamente o arquivo docker-compose.yml.\nnano docker-compose.yml  Substitua seu conteúdo pelo seguinte texto:\nversion: '2' services: r-dl-cpu_teste: image: zegkreist/r-dl-cpu container_name: r_server_1 restart: always environment: - USER=teste - USERID=1000 - PASSWORD=facil123 ports: - \u0026quot;8787:8787\u0026quot;  CTRL+O para salvar e CTRL+X para sair.\ndocker-compose up -d  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = teste e senha = facil123.\nBaixe a aplicação\ndocker-compose down  Exemplo 3: Montar volumes A ideia por trás de montar volumes é que, o container possa acessar arquivos num local persistente no host. Quando se cria algum arquivo ou alteração numa área exclusiva do container (dentro do dele), quando este for derrubado ou reiniciado está mudança será perdida. Então o que fazemos é dar permissão para o container poder ler ou ler e escrever numa região do host.\nPrimeiro vamos definir a pasta que será montada dentro do container. Vamos criar uma pasta embaixo da pasta de usuário\nmkdir /home/${USER}/teste   ${USER}: Isto acessa a variável de ambiente USER que é o nome do seu usuário  Vamos escrever algum arquivo nesta paste\necho \u0026quot;nothing to see here\u0026quot; \u0026gt; /home/${USER}/teste/arquivo.txt  Vamos subir um container com essa pasta montada utilizando o comando run\nsudo docker run -d -p 3000:8787 --name=r_server_1 -e USER='teste' \\ -e USERID='1000' \\ -e PASSWORD='facil123'\\ -v /home/${USER}/teste:/home/teste/pasta_montada zegkreist/r-dl-cpu  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = teste e senha = facil123.\nNo canto direito inferior na aba files olhe o folder com nome \u0026ldquo;pasta_montada\u0026rdquo;, veja o arquivo que está dentro, acesse e faça alguma modificação e salve.\nAgora, vamos derrubar o container.\nsudo docker container kill r_server_1  Vamos ver como está o arquivo que foi modificado dentro do container.\ncat /home/${USER}/teste/arquivo.txt  E ai? Legal? tudo certo?\nVamos agora para o docker-compose, onde podemos ter tudo isso de forma versionada se usarmos um git (\u0026lsquo;se\u0026rsquo; do verbo \u0026lsquo;vamos\u0026rsquo;).\nnano docker-compose.yml  Coloque o seguinte conteúdo:\nversion: '2' services: r-dl-cpu_teste: image: zegkreist/r-dl-cpu container_name: r_server_1 restart: always environment: - USER=teste - USERID=1000 - PASSWORD=facil123 ports: - \u0026quot;8787:8787\u0026quot; volumes: - /home/${USER}/teste:/home/teste/pasta_montada:rw  Vamos levantar:\ndocker-compose up -d  Teste o acesso em http://127.0.0.1:8787 se você estiver na sua máquina local ou http://ip-da-instancia:8787 numa instância na nuvem. É possível logar no serviço com login = teste e senha = facil123.\nNo canto direito inferior na aba files olhe o folder com nome \u0026ldquo;pasta_montada\u0026rdquo;, veja o arquivo que está dentro, acesse e faça alguma modificação e salve.\nBaixe a aplicação\ndocker-compose down  Vamos verificar como está o arquivo modificado\ncat /home/${USER}/teste/arquivo.txt  \n","date":1564617600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1564617600,"objectID":"21bdbc13d8592cee3a4287a39f7b2b82","permalink":"/tutoriais/docker/docker_compose/","publishdate":"2019-08-01T00:00:00Z","relpermalink":"/tutoriais/docker/docker_compose/","section":"tutoriais","summary":"Docker-compose O docker-compose tem como objetivo melhor organizar os container Ele nada mais é do que uma instrução de como subir contêineres e Networks, uma versão em arquivo do docker run. Vamos fazer exemplos e compará-los.\nExemplo 1: Subir um container numa porta específica Vamos subir um container numa porta específica e dar nome a ele, assim podemos identificar pelo nome do container qual aplicação está rodando com o comando run.","tags":null,"title":"Docker Compose","type":"docs"},{"authors":[],"categories":["docker","tutorial","R","Data.Table","dados"],"content":"\nOláá, olá a todos!! Espero que estejam ótimos. É sempre bom isso.\nHá muito não posto nada no blog. Vocês sabem como é \u0026hellip; vida corrida, blá blá blá, etc.\nPorém estou de férias, não posso reclamar de falta de tempo. Estou com o pé para cima\nTirando o atraso da lista de jogos (Red Dead 2, BloodBorne, God of War, Remnant, etc) veja que são alguns e não são novos.\nEstudando Scala, para ficar afiado no Spark e pá. Estudando umas aulas arcanas de programação do MIT para pegar uns conceitos de programação funcional mais a fundo ARCANO.\nLogo \u0026hellip; LOGO, tinha que fazer um Post também. No post do tutorialzinho de Docker a galera valorizou, assim irei postar uma de R também.\nTUTORIALZINHO DE R\n","date":1576886400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568943650,"objectID":"50995c6950978909de4489b6408a8158","permalink":"/post/tutorialzinho-de-r/","publishdate":"2019-12-21T00:00:00Z","relpermalink":"/post/tutorialzinho-de-r/","section":"post","summary":"Oláá, olá a todos!! Espero que estejam ótimos. É sempre bom isso.\nHá muito não posto nada no blog. Vocês sabem como é \u0026hellip; vida corrida, blá blá blá, etc.\nPorém estou de férias, não posso reclamar de falta de tempo. Estou com o pé para cima\nTirando o atraso da lista de jogos (Red Dead 2, BloodBorne, God of War, Remnant, etc) veja que são alguns e não são novos.","tags":[],"title":"Tutorialzinho de R","type":"post"},{"authors":[],"categories":["evento","nyc","strata"],"content":" \nOláá, olá a todos, espero que estejam ótimos!\nTrago um resumo de uma sessão que assisti no Strata Data Conference NY. O nome da sessão é: Securing data lakes for heavy privacy regulation. Foi apresentado por:\n Ifigeneia Derekli Mark Donsky Michael Ernest Lars George  Tudo que aqui escrevo é o meu entendimento sobre o que foi apresentado.\nEm todo o mundo está surgindo regulações em relação aos dados de pessoas. De fato isso é importante para proteção dos indivíduos em relação como suas informações são acessadas, utilizadas e vendidas.\nEstas regulações tem um forte viés na segurança, evitando que os dados sensíveis dos usuários vazem. Também na liberdade do indivíduo poder escolher se sua informação poderá ou não ser utilizada.\nHá formatos em que para alguém utilizar a informação da pessoa é necessário uma permissão prévia, tendo ela o poder de suspender a qualquer momento. Outros já permitem que os dados sejam utilizados sem a permissão prévia, mas guardando o direito do usuário suspender as atividades.\nEstas regulações virão cada vez mais, com diversas abrangências e diversos requisitos. Mas se tomarmos boas práticas de agora podemos deixar a estrutura pronta para se adequar a essas novas normas. Basicamente devemos assegurar que nossos serviços tenham:\n segurança: controle de acesso, criptografia, autenticação whitelist: poder filtrar os dados somente para aquelas pessoas que deram permissão de uso  São coisas simples, mas que podem ser quebradas nos quatro tópicos a seguir:\n Autenticação Autorização Criptografia Regulação  Autenticação A ideia aqui é descobrir quem você é! O Usuário precisar provar sua identidade para o sistema. Em tempos de home office essa parte é muito importante, pois é uma porta de entrada. Esta porta deve ser aberta somente para pessoas autorizadas.\nAs pessoas autorizadas estão numa \u0026ldquo;lista\u0026rdquo; seleta, o usuário precisa então provar sua identidade. A identidade é um objeto único identificatório, um username, um e-mail, etc. Mas uma identidade não significa conta, uma conta pode possuir mais de uma identidade.\nAgora a prova fornecida para atestar a veracidade da pessoa em relação a identidade pode ser de três tipos:\n Coisas que você sabe: uma senha. Coisas que você possui: um smart card, um app de tokens, etc. Coisas que você é: sua Iris, digitais, DNA, etc.  Quanto mais dessas acumuladas melhor para a segurança. Por isso sempre use MFA.\nEstá etapa é extremamente sensível, cheia de pormenores, é recomendado que não se faça uma aplicação para isso, mas sim utilizar algo já pronto e testado, um software ou serviço. Há vários serviços e programas que fazem essa parte, o importe é utilizar algo que se encaixe no que você precisa. Que seja um serviço que tenha uma equipe dando suporte, corrigindo bugs e fazendo melhorias constantemente.\nHá gerenciadores em filesystem, como o login de linux ou até mesmo no Windows. Mas isso não foi feito para ser utilizado em larga escala. Existem métodos de onde a autenticação da identidade é feita por um agente externo como LDAP. Hoje, também temos a possibilidade de sistema de autenticação como serviço, a exemplo do AWS cognito, Azure active directory, Auth0, etc. Eles podem usar diferentes tipos de tecnologia por trás, OAuth, OpenID, SAML. Esses caras como serviço facilitam o transito das identidades entre os recursos de uma forma fácil e segura, onde tokens são gerados na hora, com curto tempo de validade, etc. Sem decorar a porrada de senhas. É fácil identificar o acesso de algo e cortar os acessos como um todo.\nAutorização Uma vez que o sistema sabe quem eu sou a pergunta aqui agora muda. Se eu sou quem eu sou, o que eu posso fazer?\nO objetivo dessa parte é colocar cada um no seu quadrado. Há diferentes tipos de usuários. Com isso há diferentes tipos de permissões para cada usuário. Tem aqueles que podem tomar ações, enquanto outros devem apenas consumir algo, também temos o que fazem os dois. Em cima disso tudo ainda há uma questão de zonas. Em quais dados / zonas os usuários poderão consumir/ tomar ações. É necessário manter controle de todo esse \u0026ldquo;movimento\u0026rdquo;.\nExistem diversas formas de realizar esse controle, os palestrantes citaram os seguintes exemplos:\n ACL (Access control lists): ACL é usado diretamente no objeto. S3, HDFS, Hbase, ADLS Gen2, GCs, etc. PROS: simples, da conta do recado, bem comum no mercado. CONS: baixo nível. Não pode ser aplicado holisticamente, tem que ser manejado sistema por sistema, arquivo a arquivo.\n RBAC (Role based access control): Role é uma função que tem significado para uma empresa ou grupo. Usuários ou grupos recebem uma ou mais funções. Cada Função é associada com certas permissões (políticas). As funções são extraídas da identidade, feitas depois da autenticação, permitindo que elas sejam manejadas separadamente. Exemplo: AWS IAM e google IAM. POS: simples, fácil entendimento, mais eficiência, compliance. CONS: não é dinâmico o suficiente, não é muito granular (pode ser feito, mas exige mais esforço), no final pode haver muitas funções para manejar.\n ABAC (Attribute based access control): Atributo é algo que descreve o usuário/grupo/dados/contexto. É Mais dinâmico que o RBAC, se o atributo muda as permissões o segue. POS: dinâmico, granularidade baixa, eficiência, compliance. CONS: bem mais complexo que RBAC, pode continuar com muitas políticas.\n  O importante é poder ter ao mesmo tempo granularidade nas permissões e controle sobre as permissões. Isto para que se tenha um sistema flexível e seguro. Caso tenha uma falha nos acessos que seja possível identificá-la de forma rápida e resolvê-la sem grandes efeitos colaterais.\nAs políticas podem cuidar disso, mas as permissões de visualização deve descer ao nível da linha do dado. Imagine que, uma pessoa permita que você possa utilizar seus dados, mas não sua filial na Europa. Então as visualizações \u0026ldquo;europeias\u0026rdquo; não devem receber esses dados em específico.\nNuma arquitetura de banco de dados, é uma boa prática nunca exibir as tabelas bases para ninguém. O usuário/analista/cientista de dados/executivo que for acessar estes dados devem o fazer via uma camada que verifica seus acessos. Assim a pessoa que irá trabalhar com estes dados irá ver uma versão da tabela base filtrada por uma tabela de controle de acesso.\nCriptografia Confesso que este foi o ponto da palestra em que menos me sinto confortável para falar. Por isso irei apenas passar por cima, num modo mais conceitual.\nA pergunta aqui não é \u0026ldquo;Devemos criptografar os dados?\u0026rdquo;, mas sim \u0026ldquo;Quando criptografar os dados?\u0026rdquo;. A criptografia oferece proteção e confidencialidade aos nossos dados, dados criptografados mesmo que vazados estão seguros (desde que capturou não tenha a chave de decodificação). É necessário manter integridade dos dados (evitando perdas acidentais) e a confidencialidade. Com a técnica apropriada é possível manter os dois.\nQuando transferimos dados de um lado para outro nós estamos utilizando fios, literalmente. Caso estes fios estejam numa rede pública, na internet por exemplo, eles são acessíveis para outras pessoas. Caso não seja utilizado algum tipo de criptografia em trânsito os dados estão sendo transferidos abertamente. Qualquer um com acesso nesta rede pública pode capturar estes dados sendo transferidos e observar o que eles realmente são. Agora, utilizando algum tipo de criptografia de transferência os dados ainda podem ser \u0026ldquo;capturados\u0026rdquo;, porém não são recuperáveis, com exceção das pontas (aquele que enviou o dados e aquele que deve receber). Basicamente o que é capturado é uma colação de bytes aleatórios.\nQuando os dados estão parados (at rest) também é importante criptografar os dados. Pois isso protege os dados de pessoas que já estão na rede, pode ser um usuário interno mal intencionado, ou até mesmo uma invasão.\nPorém tudo isso vem a um custo. Para podermos manter os dados criptografados é necessário que seja feito um manejamento das chaves de criptografia. São por estas que é possível criptografar e descriptografar os dados. E isto é de extrema importância, veja, se alguém tiver acesso às chaves ele terá acesso aos dados. Caso alguém se atrapalhe e as chaves sejam perdidas você nunca mais terá acesso a aqueles dados. Então é necessário que tenha um processo de governança sobre estas chaves, deixando elas num local diferentes dos dados, com expiração e rotação, com backups, etc.\nRegulação Não é possível prever todos os detalhes de um nova regulação. Porém com boas práticas podemos estar preparados para elas. Fornecendo segurança, controle de acesso linha a linha para usuários são exemplos disso.\nE necessário conhecer conhecer quais dados você possui no seu data lake. Quais são os dados sensíveis, quais conjunto de dados, mesmo que não sejam sensíveis possam identificar um indivíduo. Crie catálogos de todos os dados, crie tags para cada coluna, metadados EVERYWHERE.\nComo os dados estão sendo usados? Por quem os dados estão sendo usados.\nSaber a linha temporal dos dados. De quando ele entra até quando ele sai para o usuário final, quais são as etapas de transformações. Guarde o estado de cada cálculo, entrada e saída, hoje o custo de armazenamento de dados é o mais baixo da história. Podemos guardar todo o histórico de transformação. Está é uma etapa necessária, já que muitas das regulações que estão surgindo ao redor do mundo exigem que isto seja feito e por um longo período de tempo.\nSEMPRE devemos pensar na segurança por default. Hoje, muitos sistema são construídos para então serem adicionados etapas de segurança. Isto deve ser invertido, devemos pensar nos sistemas e nas soluções de forma a fornecer o máximo de segurança. Encriptar dados, controle de acesso, anonimização pseudoanonimização (xuberar), acesso fino aos dados.\nSempre implementar mecanismos de validar o consentimento das pessoas que de fato são os donos de suas informações pessoais. Toda aplicação deve receber os dados após a validação do consentimento, nunca dos dados base.\n","date":1569283200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569289250,"objectID":"99b5abf360081fed1741c84e9e9b5478","permalink":"/post/strata-data-conference-regulation/","publishdate":"2019-09-24T00:00:00Z","relpermalink":"/post/strata-data-conference-regulation/","section":"post","summary":"Oláá, olá a todos, espero que estejam ótimos!\nTrago um resumo de uma sessão que assisti no Strata Data Conference NY. O nome da sessão é: Securing data lakes for heavy privacy regulation. Foi apresentado por:\n Ifigeneia Derekli Mark Donsky Michael Ernest Lars George  Tudo que aqui escrevo é o meu entendimento sobre o que foi apresentado.\nEm todo o mundo está surgindo regulações em relação aos dados de pessoas.","tags":[],"title":"Strata Data Conference Securing data lakes for heavy privacy regulation","type":"post"},{"authors":[],"categories":["docker","tutorial","linux"],"content":"\nOláá, olá a todos!! Espero que estejam ótimos. É sempre bom isso.\nVenho por meio deste, meu primeiro post neste blog, informar que coloquei um \u0026ldquo;tutorialzinho\u0026rdquo; de docker também neste blog, veja só!\nO Docker nos permite abstrair uma série de problemas. Quando fazemos análises de dados não sabemos exatamente o que utilizar durante o processo.\nPartimos de uma ideia, uma hipótese, mas isto não é fixo, a partir do aprendizado e da familiaridade que vai se construindo ao trabalhar com os dados novas ideias surgem, e com isso a necessidade de novas ferramentas para algo em específico surge. Essa nova ferramenta pode vir em formato de network, de algum pacote, uma lib, das nuvens \u0026hellip; de baixo da terra, sei lah.\nA questão aqui é ir entulhando seu sistema operacional com toda essas libs e a carga de dependências que normalmente vem junto. As vezes algum componente não conversa bem com outro e sai briga. Logo seu OS vai ficando sujo. Aqui que o Docker ajuda.\nQuando se desenvolve dentro de um container Docker você tem toda a liberdade de derrubar as paredes da casa, se o telhado cair na sua cabeça tudo bem!! Apenas restarte o container e tá tudo certo, a casa está de pé novamente, seu OS limpo da mesma forma, seu ambiente de desenvolvimento intacto.\nHá quase um ano eu trabalho utilizando uma imagem específica, tem basicamente tudo que eu preciso, do R server ao Latex! A imagem é gigante? É sim! Mas se eu precisar formatar meu PC em 10 minutos instalo o docker, baixo a imagem e estou com meu ambiente de desenvolvimento que já conheço de pé.\nO Docker facilita também a parte de colocar as coisas em produção, já que você consegue versionar seu ambiente de execução inteiro.\nPor isso e mais um pouco resolvi colocar um tutorial de Docker aqui. Ensino a instalar, falo mais detalhadamente sobre alguns comandos para quem não está muito acostumado com o linux. Exemplifico os principais comandos e mostro a mágica que é o docker-compose aquela delícia!!!\nDê uma olhadinha! XD\ntutorialzinho\n","date":1568937600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1568943650,"objectID":"05f0efe35748481ab3ede84384623f95","permalink":"/post/tutorialzinho-de-docker/","publishdate":"2019-09-20T00:00:00Z","relpermalink":"/post/tutorialzinho-de-docker/","section":"post","summary":"Oláá, olá a todos!! Espero que estejam ótimos. É sempre bom isso.\nVenho por meio deste, meu primeiro post neste blog, informar que coloquei um \u0026ldquo;tutorialzinho\u0026rdquo; de docker também neste blog, veja só!\nO Docker nos permite abstrair uma série de problemas. Quando fazemos análises de dados não sabemos exatamente o que utilizar durante o processo.\nPartimos de uma ideia, uma hipótese, mas isto não é fixo, a partir do aprendizado e da familiaridade que vai se construindo ao trabalhar com os dados novas ideias surgem, e com isso a necessidade de novas ferramentas para algo em específico surge.","tags":[],"title":"Tutorialzinho de Docker","type":"post"}]